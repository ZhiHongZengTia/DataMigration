# 狄泰数据结构

==课程目标==

1. 创建可复用的数据结构软件库

2. 分析并优化C++中的实用类

面向对象、模板技术、异常处理技术

---

程序时解决问题的步骤描述，《计算机程序设计的艺术》——高纳德

程序 = 数据结构 + 算法 

数据结构研究：**非数值计算**类型的程序问题，数据间的组织和操作方式，数据的逻辑结构和存储结构

---

数据元素：组成数据的基本单元

数据项：一个数据元素由若干数据项组成

数据对象：性质相同的数据元素的集合

```c++
struct Student;     // 数据结构
Student s;        // 数据元素
Student sArray[10];  // 数据对象
s.name;          //  数据项
```

**数据结构指数据对象中数据元素之间的关系**

数据元素之间不是独立的，存在特定的关系，这些关系即结构，如数组各个元素之间是线性关系

数据结构静态的描述了数据元素之间的关系

---

==逻辑结构==

集合结构：数据元素之间没有特别的关系，仅同属相同集合

线性结构：数据元素之间是**一对一**的关系

树形结构：数据元素之间存在**一对多**的层次关系

图形结构：数据元素之间是**多对多**的关系

---

计算机==物理结构==：在计算机中的存储形式

顺序存储结构：将数据存储在地址连续的存储单元里

链式存储结构：将数据存储在任意的存储单元里，通过保存地址的方式找到相关联的数据元素

---

高效的程序：恰当的数据结构 + 合适的算法（求解步骤的描述）

数据结构是算法处理问题的载体

算法在计算机中表现为指令的有限序列，算法是独立存在的一种解决问题的方法和思想

对算法而言，语言不重要，重要的是思想

数据结构和算法的训练贯穿整个软件开发的职业生涯

---

算法的基本准则：正确性

- 对于**合法数据**能够得到满足要求的结果

- 算法能够处理**非法输**入，并得到合理结果

- 算法对于**边界数据**和**压力数据**都能得到满足要求的结果

---

算法效率的度量

事后统计法：比较不同算法对同一组输入数据的运行处理时间（依赖硬件以及环境，测试数据选取相对困难）

**事前分析估算**：依据统计的方法对算法效率进行估算

主要因素：（1）算法采用的策略和方法；（2）问题的输入规模；（3）好坏编译器所产生的代码；（4）计算机执行速度

---

==算法的时间复杂度==（对时间需求量的定性描述）、空间复杂度（对空间需求量的定性描述）

**大O表示法：算法效率严重依赖于操作数量，因此只关注操作数量的最高次项**

```c++
O(6) = O(1)
O(2n+1) = O(2n) = O(n)
O(3n^2+n+1) = O(3n^2) = O(n^2)  // 只需要关注最高阶项就能得出结论
```

常见的，常数阶、线性阶、对数阶、指数阶

```C++
//  线性阶时间复杂度 ：O(n)
for(int i = 0;i<n;++i){}

//  对数阶复杂度：O(logn)
while(i<n){ i *=2; }   // 循环次数 log2(n)
while(i<n){ i *=5; }   // 循环次数 log2(n)  底数2不变

//  指数阶复杂度：O(N^2)
for(int i = 0;i<n;++i)
{
	for(int j = 0;j<n; ++j){}
}
```

特殊的

```c++
//  O(0.5n^2+0.5n)  =  O(n^2)
for(int i = 0;i<n;++i)
{
	for(int j = i;j<n; ++j){}
}
```

> 算法时间复杂度排序
>
> O(1) < O(logn) < O(n) < O(n*logn) < O(n^2)      // 推荐算法
>
> < O(n^3)
>
> < O(2^n) < O(n!) < O(n^n)       // 不用

---

==空间复杂度==，与时间复杂度推导一致

S(n)  = S( f(n) )

```c++
long ret;
int* array = new int[n];  // S(n+1) = S(n)

```

空间换时间是工程中常用的策略，因为硬件的发展速度比软件快

---

嵌入式中操作系统内核里设计的数据结构

内存管理：需要设计页映射表相关的数据结构和访问算法

进程管理：需要设计表示进程的数据结构PCB（进程控制块）和资源分配算法

线程管理：需要设计表示线程的数据结构TCB（线程控制块）和调度算法

## 泛型编程

数据结构关注于数据元素之间的关系，专注于特定结构之上的算法

而不关心数据元素的具体类型

因此使用泛型编程：不考虑具体数据类型的编程方式

`C++`中的**函数模板**和**类模板**可以实现泛型编程

==函数模板==

```c++
template <typename T> 
void Swap(T& a, T& b){}

Awap(int1,int2);  // 自动类型推导调用
Swap<float>(c,d)  // 具体类型显式调用
```

==类模板==：非常适用于编写数据结构相关代码

```c++
template <typename T>
class Op{ public: T process(T v){return v*v;} };

// 类模板的使用
Op<int> OpInt;  // 只能显式指定具体类型
OpInt.process(5);
```

==智能指针==：是`C++`中用模板技术实现的类

内存泄漏`Bug`

- 动态申请堆空间，用完后不归还

- `C++`中**没有垃圾回收机制**

- 指针无法控制所指堆空间的生命周期

智能指针需求

- 指针生命周期结束时**主动释放堆空间**

- 一片堆空间**最多只能由一个指针标识**

- 杜绝指针运算和指针比较

智能指针意义：**最大程序的避免内存问题**

智能指针军规：**只能用来指向堆空间的单个对象或变量**









## C++异常

现代C++中包含必要的异常类族，内置异常处理的语法元素`try ...  catch  ...`

- try 语句处理正常代码逻辑

- catch 语句处理异常情况，catch(...) 表示处理所有类型的异常

- try 语句中的异常由对应的 catch 语句处理

```c++
try
{
	double r = divide(1,0);
   cout<<"function divide\n";  // 产生了异常，不会执行
}
catch(...)
{
	cout<<"divide by zero\n";
}


double divide(double a,double b)
{
    const double delta = 0.000001;
    double ret;
    if( !((-delta)<b) && (b<delta)) )
        ret = a/b;
    else
        throw 0;  // 抛出异常，函数不会往下运行了，会异常返回 0
    return ret;
}
```

throw 抛出的异常必须被 catch 处理了

- 当前函数**能够处理异常**，程序继续往下执行

- 当前函数**无法处理异常**，则函数**停止执行**，并返回（异常返回）

---

同一个try可以跟上多个catch语句

- catch语句可以定义具体处理的异常类型

- **不同类型的异常**由不同的 catch 语句负责处理

- try 语句中可以抛出任意类型的异常

- 任何异常都只能被捕获（catch）一次

```c++
try{  }
catch(Type t1){}  // 异常抛出后，至上而下严格匹配（不进行任何的类型转换） 每一个 catch 语句处理的类型
catch(Type t2){}
catch(Type t3){}

// 如
try{ throw "cc"; }
catch(int i){  cout<<"catch i = "<<i;  }  
catch(double d){  cout<<"catch d = "<<d;  }
catch(char c){  cout<<"catch c = "<<c;  }
catch(char* pc){  cout<<"catch *pc = "<<*pc;  }
catch(const char* cpc){  cout<<"const catch *cpc = "<<*cpc;  } // 异常处理匹配成功
```

---

**异常类构建**

- 异常的类型可以是**自定义类类型**

- 对于类类型异常的匹配依旧是**至上而下严格匹配**

- **赋值兼容性原则（子类可以赋值给父类）**在异常匹配中依然适用

一般而言

- 匹配子类异常的`catch`放在上部

- 匹配父类异常的`catch`放在下部

异常机制能够分离库中代码的正常逻辑和异常逻辑

顶层父类 `Exception` ，子类如下

| ArithmeticException       | 计算异常 |
| ------------------------- | -------- |
| NullPointerException      | 空指针   |
| IndexOutOfBoundsException | 越界     |
| NoEnoughMemoryException   | 内存不足 |
| InvalidParameterException | 参数错误 |
| InvalidOperationException | 非法操作 |





```c++
namespace DTLib
{
	class Exception
	{
    protected :
       	char* m_message;
        char* m_location;
      	 void init(const char* message, const char* file; int line);

    public:
        Exception(const char* message);
        Exception(const char* file, int line);
        Exception(const char* message, const char* file; int line);

        Exception(const Exception& e);
        Exception & operator= (const Exception& e);

        virtual const char* message() const;
        virtual const char* location() const;

        virtual ~Exception() = 0;  // 抽象类
	};	
}
```

















## 顶层父类的创建

当代软件架构实践经验

- 尽量使用**单重继承**的方式进行系统设计，即只继承一个父类

- 尽量保存系统中只存在**单一的继承树**，即定义一个顶层抽象父类

- 尽量使用**组合关系**代替继承关系

---

new失败后，古代的编译器会返回NULL，现代的编译器会抛出一个异常

创建顶层父类 DTLib::Object 类的意义

- 遵循经典设计原则：**所有数据结构都继承自 OBject 类**
- **统一动态内存申请的行为**，提高代码的移植性，在堆中创建`Object`子类的对象，失败时返回`NULL`
- `Object`是抽象类，所有子类可以进行动态类型识别

```c++
class Object  // 纯虚父类，所有子类都能进行动态类型识别
{
	public:
	void* operator new(unsigned int size) throw();  // 不抛出异常，new失败返回NULL
	void operator delete(void* p);
	void* operator new[] (unsigned int size) throw();
	void operator delete[] ( void* p);
	~Object() = 0;  // 抽象类
}
```







---

迭代开发：打造可复用库

单一继承树：所有类都继承自`Object`，规范堆对象创建时的行为

只抛异常，不处理异常：使用`THROW_EXCEPTION`抛出异常，提高可移植性

弱耦合性：不使用标准库中的类和函数，提高移植性









## 线性表

`List`的表现形式：具有相同类型的n个数据元素的有限序列

- 0或多个数据元素组成的集合

- 数据元素在位置上**有序排列**

- 数据元素个数有限

- 数据元素的类型必须相同

---

线性表的常用操作：

将元素插入信息表、删除、获取目标位置处元素的值、设置目标位置元素的值、获取长度、清空线性表

```c++
template <typename T>
class List: public Object
{
public:
    List();
    virtual bool insert(const T& e) = 0;  // 向线性表最后插入元素
    virtual bool insert(int i, const T& e) = 0;  // 向线性表位置i插入元素
    virtual bool remove(int i) =0;
    virtual bool set(int i, const T& e) = 0 ;
    virtual bool get(int i, T& e) const  = 0 ;
    virtual int length() const = 0;
    virtual void clear() = 0 ;
        	
}

List<int>* l1 = NULL;  // 测试使用，因为不能创建对象
```

### 线性表的顺序存储结构

用一段地址连续的存储单元依次存储线性表中的数据元素

存储空间：T* m_array

长度：int m_length

```
template <typename T>
class SeqList
{

}
```



==1、获取元素==

```c++
bool SeqList<T>::get(int i, T& e) const
{
	bool ret = (0<= i)&&( i< m_length);
	if(ret)
	{
		e = m_array[i];
	}
	return ret;s
}
```

==2、插入元素==

```c++
bool SeqList<T>::insert(int i, const T& e)
{
	bool ret = (0 <= i ) && ( i<= m_length);
	ret = ret && ( (m_length+1)<= capacity );
	if(ret)
	{
		for(int p = m_length - 1; p>=i; p--)
		{
			m_array[p+1] = m_array[p];
		}
		m_array[i] = e;
		m_length ++;
	}
	return ret;
}  
```

==3、删除==

```c++
bool SeqList<T>::remove(int i)
{
	bool ret = ( (0<=i) && (i<m_length) )
	if(ret)
	{
		for(int p = i ; p< m_length; p++)
		{
			m_array[p] = m_array[p+1];
		}
		m_length--;
	}
	return ret;
}
```

### 顺序存储结构的抽象实现

`SeqList `

抽象类对象（不能创建对象，但是可以创建指针），**存储空间的位置和大小由子类完成**

实现顺序存储结构线性表的**关键操作**（增，删，查）

**提供数组操作符**，方便快速获取元素

```c++
template <typename T>
class SeqList:public List<T>
{
   protected:
    T* m_array;  // 顺序存储空间
    int m_length;  // 当前线性表长度
	public:
    bool insert(int i, const T& e);  // 复杂度 O(n)
    bool remove(int i);          // 复杂度 O(n)
    bool set(int i, const T& e);
    bool get(int i, T& e) const ;
    int length() const;
    void clear();
    T& operator[] (int i);  // 【】数组访问方式
    T operator[] (int i) const;
    virtual int capacity() const = 0 ;	// 顺序存储空间的容量
};

template <typename T>
bool insert(int i, const T& e)
{
    bool ret = ( (0<=i) && (i<=m_length) );
    ret = ret && (m_length < capacity());
    if(ret)
    {
        for(int p = m_length-1; p>=i; p--)
        {
            m_array[p+1] = m_array[p];
        }
        m_length[i] = e;
        m_length ++;
    }
    return ret;
}

bool remove(int i)
{
    bool ret =  ( (0<=i) && (i<=m_length) );
    if(ret)
    {
        for(int p = i; p<m_length-1; p++)
        {
            m_array[p] = m_array[p+1];
        }
       m_length --;
    }
    return ret;
}

bool set(int i, const T& e)
{
    bool ret =  ( (0<=i) && (i<=m_length) );
    if(ret)
    {
        m_array[i] = e;
    }
    return e;
}

bool get(int i, T& e) const
{
    bool ret =  ( (0<=i) && (i<=m_length) );
    if(ret)
    {
        e = m_array[i];
    }
    return ret;
}

int length() const
{
    return m_length;
}

void clear()
{
    m_length = 0;
}

T& operator[] ( int i)
{
    if((0<=i) && (i<=m_length))
    {
        return m_array[i];
    }
    else
    {
        THROW_EXCEPTION(IndexOutOfBoundsException,"parameter i is invaild...");
    }
}

T operator[] ( int i) const 
{
    return const_cast<SeqList<T>&>(*this)[i];
}

```

### StaticList和DynamicList

`StaticList`

使用原生数组作为顺序存储空间

使用模板参数决定数组大小

```c++
template <typename T, int N>
class StaticList : public SeqList<T>
{
protected:
	T m_space[N];
public:
	StaticList();
	int capacity() const;
}
```

`DynamicList`

- 申请连续堆空间作为顺序存储空间

- 动态设置顺序存储空间的大小

- 保证重置顺序存储空间时的异常安全性

异常安全的概念：不允许有泄漏，和数据破坏

函数异常安全的基本保证：如果异常被抛出，（1）对象内的成员仍然能够保持有效状态，（2）没有数据的破坏及资源泄漏

```c++
template <typename T>
class DynamicList : public SeqList<T>
{
protected:
	int m_capacity;  // 顺序存储空间的大小
	public:
	DynamicList(int capacity);  // 申请空间
	int capacity() const;  // 重新设置存储空间的大小
	void resize(int capacity);  // 归还空间
	~DynamicList();
}；
```

==区别==

`StaticList` 通过模板参数定义顺序存储空间

`DynamicList`通过动态内存申请定义顺序存储空间

`DynamicList`支持动态重置存储空间的大小

`DynamicList`中的`resize()`需要保证异常安全性







### 顺序存储线性表的分析



SeqList<int>

SeqList<string>  他们的效率不一样



---

==问题一==

`StaticList` 赋值操作时，会使得指向同一片空间

```c++
void Test2StaticList()
{
    StaticList<int*, 5> list1;
    StaticList<int*, 5> list2;

    for(int i = 0 ; i<list1.capacity(); ++i)
    {
        list1.insert(0,new int(i));
    }
    list2 = list1;  // 指向了同一片堆空间
    
    for(int i = 0; i<list1.length(); ++i)
    {
        delete list1[i];
        delete list2[i];  // ERROR 同一个空间释放了两次 double free detected in tcache 2

    }
}
```

`DynamicList` 赋值操作时会使得指向同一片空间

```c++
void Test2DynamicList()
{
    DynamicList<int> list1(5);
    DynamicList<int>  list2 = list1;

    for(int i = 0 ; i<list1.capacity(); i++)
    {
        list1.insert(0,i);
        list2.insert(0,i*i);
    }

    cout<<"capacity:"<<list1.capacity()<<",length:"<<list1.length()<<endl;

    for(int i = 0  ; i<list1.length(); ++i)
    {

        cout<<"i:"<<i<<",list1="<<(list1[i])<<", list2 = "<<list2[i]<<", ";
        cout<<"addr list1:"<<&list1[i]<<" , list2"<<&list2[i]<<endl;
    }
}
```

==解决方案==

对于容器类型的类，禁用拷贝构造和赋值操作（即，容器中的东西不允许复制，线性表就是容器）

```c++
template <typename T>
class List : public Object
{
protected:
	List(const List&);  // 将拷贝构造函数设为 protected，就相当于禁止了拷贝构造
	List& operator= (const List&);
public:
	List(){}
	...
};
```

测试

```
DynamicList<int> list1(5);
DynamicList<int>  list2 = list1;  // ERROR，编译出错
```

---

==问题二==

```c++
StaticList<int,  5> list1;
for(int i = 0; i<list1.capacity(); ++i)
{
	list1[i] = i*i;   // ERROR，运行出错，抛出越界异常。将线性表当作数组使用
}

```

因为设计时候，线性表必须先插入元素，才能使用` []` 访问元素

```c++
T& SeqList<T>::operator[] (int i)  // 【】数组访问方式
 {
     bool ret = ((i>=0) && (i<m_length) );
     if(ret)
     {
         return m_array[i];
     }
     else
     {
         THROW_EXCEPTION(IndexOutOfBoundsException,"parameter i is invalid...");
     }
 }
```

线性表重载了` []` 操作符，是为了方便获取目标位置出的元素。线性表与数组使用形式上类似，本质不同，不能代替数组使用

---

==总结==

顺序存储线性表的插入和删除（O(n)）存在效率隐患

线性表作为容器类，应避免拷贝构造和复制

顺序存储线性表与数组不同，不能误用

## 数组类

需求，创建数组类代替原生数组

数组类包含长度，能够主动发现越界访问



`Array` 抽象列模板

1. 存储空间的位置和大小由子类完成
2. 重载`[]`操作符，判断访问下标是否合法
3. 提供数组长度的抽象访问函数
4. 提供数组对象间的赋值操作



```c++
template <typename T>
class Array : public Object
{
protected:
	T* m_array;
public:
	virtual bool set(int i, const T& e);
	virtual bool get(int i, const T& e) const;
	virtual int length() const = 0 ;
	
	T& operator[] (int i);
	T operator[] (int i) const ;
};
```

---

### StaticArray与DynamicList 

需求

1. 封装原生数组
2. 使用模板参数决定数组大小
3. 实现函数返回数组长度
4. 实现拷贝构造和赋值

```c++
template<typename T, int N>
class StaticArray: public ArrayM<T>
{
protected:
    T m_space[N];
public:
    StaticArray();
    StaticArray(const StaticArray<T,N>& obj);
    StaticArray<T,N>& operator= (const StaticArray<T,N>& obj);

    int length() const;
};
```

---

`DynamicArray`需求

1. 类模板，动态确定内部数组空间的大小
2. 实现函数返回数组长度
3. 实现拷贝构造和赋值

```c++
#ifndef DYNAMICARRAY_H
#define DYNAMICARRAY_H

#include "object.h"
#include "arraym.h"

namespace DTLib {

template< typename T>
class DynamicArray:public ArrayM<T>
{
protected:
    int m_length;
public:
    DynamicArray(int length);
    DynamicArray(const DynamicArray<T>& obj);
    DynamicArray<T>& operator= (const DynamicArray<T>& obj);

    int length() const override;
    void resize(int length);

    ~DynamicArray();
};

template< typename T>
DynamicArray<T>::DynamicArray(int length)
{
    this->m_array = new T[length];
    if(this->m_array != nullptr)
    {
        this->m_length = length;
    }
    else
    {
        THROW_EXCEPTION(NoEnoughMemoryException,"DynamicArray no enough memory to create object...");
    }

}

template< typename T>
DynamicArray<T>::DynamicArray(const DynamicArray<T>& obj)
{
    this->m_array = new T[obj.m_length];
    if(this->m_array != nullptr)
    {
        this->m_length = obj.m_length;
        for(int i = 0 ; i<this->m_length; ++i)
        {
            this->m_array[i] = obj.m_array[i];
        }
    }
    else
    {
        THROW_EXCEPTION(NoEnoughMemoryException,"DynamicArray no enough memory to create object...");
    }
}

template< typename T>
DynamicArray<T>& DynamicArray<T>::operator= (const DynamicArray<T>& obj)
{
    if(this != &obj)
    {
        T* newarray = new T[obj.m_length];
        for(int i = 0 ; i<obj.m_length; ++i)
        {
            newarray[i] = obj.m_array[i];
        }
        T* temp = this->m_array;

        this->m_array = newarray;
        this->m_length = obj.m_length;

        delete[] temp;
    }
    else
    {
        THROW_EXCEPTION(NoEnoughMemoryException,"DynamicArray no enough memory to create object...");
    }
    return *this;
}

template< typename T>
int DynamicArray<T>::length() const
{
    return this->m_length;
}

template< typename T>
void DynamicArray<T>::resize(int length)
{
    if(length != m_length)
    {
        T* newarray = new T[length];

        if(newarray!= nullptr)
        {
            int size = (length < this->m_length) ? length : this->m_length;
            for(int i =0; i<size; ++i)
            {
                newarray[i] = this->m_array[i];
            }

            T* temp = this->m_array;
            this->m_array = newarray;
            this->m_length = length;
            delete[] temp;
        }
        else
        {
            THROW_EXCEPTION(NoEnoughMemoryException,"DynamicArray no enough memory to resize object...");
        }

    }
}

template< typename T>
DynamicArray<T>::~DynamicArray()
{
    delete[] this->m_array;
}
}
#endif // DYNAMICARRAY_H
```

优化

```c++
#ifndef DYNAMICARRAY_H
#define DYNAMICARRAY_H

#include "object.h"
#include "arraym.h"

namespace DTLib {

template< typename T>
class DynamicArray:public ArrayM<T>
{
protected:
    int m_length;
    T* copy(T* array1, int length, int newLength);
    void init(T* array, int length);

    void update(T* array, int length);
public:
    DynamicArray(int length);
    DynamicArray(const DynamicArray<T>& obj);
    DynamicArray<T>& operator= (const DynamicArray<T>& obj);

    int length() const override;
    void resize(int length);

    ~DynamicArray();
};

template< typename T>
T* DynamicArray<T>::copy(T* array1, int length,int newLength)
{
    T* ret = new T[newLength];
    {
        if(ret != nullptr)
        {
            int size = (length < newLength) ? length: newLength;
            for(int i =0; i<size; ++i)
            {
                ret[i] = array1[i];
            }
        }
    }
    return ret;
}

template< typename T>
void DynamicArray<T>::init(T* array, int length)
{
    if(array != nullptr)
    {
        this->m_array = array;
        this->m_length = length;
    }
    else
    {
        THROW_EXCEPTION(NoEnoughMemoryException,"DynamicArray no enough memory to init object...");
    }
}

template< typename T>
void DynamicArray<T>::update(T* array, int length)
{
    if(array != nullptr)
    {
        T* temp = this->m_array;
        this->m_array = array;
        this->m_length = length;
        delete[] temp;
    }
    else
    {
        THROW_EXCEPTION(NoEnoughMemoryException,"DynamicArray no enough memory to update object...");
    }
}

template< typename T>
DynamicArray<T>::DynamicArray(int length)
{
    init(new T[length],length);
}

template< typename T>
DynamicArray<T>::DynamicArray(const DynamicArray<T>& obj)
{
    T* array = copy(obj,obj.length(), obj.length());
    init(array,obj.length());
}

template< typename T>
DynamicArray<T>& DynamicArray<T>::operator= (const DynamicArray<T>& obj)
{
    if(this != &obj)
    {
        T* array = copy(obj.m_array, obj.m_length, obj.m_length);
        update(array,obj.m_length);
    }
    return *this;
}

template< typename T>
int DynamicArray<T>::length() const
{
    return this->m_length;
}

template< typename T>
void DynamicArray<T>::resize(int length)
{
    T* array = copy(this->m_array,m_length,length);
    update(array,length);
}

template< typename T>
DynamicArray<T>::~DynamicArray()
{
    delete[] this->m_array;
}
}
#endif // DYNAMICARRAY_H
```

---

总结

`StaticArray` 通过封装原生数组实现

`DynamicArray` 动态申请堆空间，使得长度可变



## 线性表的链式存储结构

顺序存储结构线性表（顺序表）的最大问题：插入和删除需要移动大量数据

链式存储定义：数据除了存储本身的信息外，还存储其后续的信息

基于链式存储结构的线性表（链表），每个节点都包含数据域和指针域

- 数据域：存储数据元素本身，链表的数据元素在物理内存中无相邻关系

- 指针域：存储相邻节点的地址

| 单链表       | 每个节点只包含直接后继的地址线性                             |
| ------------ | ------------------------------------------------------------ |
| 循环链表     | 单链表中的最后一个节点的直接后继是第一个节点                 |
| 双向链表     | 单链表中的节点包含直接前驱和后继的地址信息                   |
| 双向循环链表 | 双向链表的最后一个直接后继是第一个节点，第一个节点的前驱是最后一个节点 |

---

链表基本概念

头节点：辅助节点，包含指向第一个数据元素的指针（不存储数据元素）。作用：方便插入和删除操作

数据节点：表现为 （数据元素，地址）

尾节点：最后一个数据节点，包含的地址为 `nullptr`

```c++
struct Node: public Object
{
	T value;
	Node* next;
};
```

---

1、插入（插入到n）

1. 从头节点开始，通过current指针定位到目标位置，即 current  = current -> next;循环n次，就找到了第n个节点
2. 从堆空间申请新的 Node 节点
3. 执行操作如下

```c++
node -> value = e;
node -> next = current -> next;
current ->next = node;
```

2、删除（删除第n个节点）

1. 从头节点开始，通过current指针定位到目标位置
2. 使用 toDel 指针指向需要删除的节点
3. 执行操作

```c++
toDel = current -> next;
current -> next = toDel -> next;
delete toDel;
```

### 单链表的实现

LinkList

- 类模板，通过头节点访问后续节点

- 定义内部节点类型 Node，用于描述数据域和指针域

- 实现信息表的关键操作（增删查等）

```c++
template <typename T>
class LinkList: public List<T>
{
protected:
	struct Node : public Object
	{
		T value;
		Node* next;
	};
	Node m_header;
	int m_length;
public:
	LinkList();
};
```



头节点的隐患，只使用了其 `next`，而没有使用 `value`

```c++
class Test
{
public:
	Test() {  throw(0); }
};

LinkList<Test> list;  // 会调用LinkList的对象，构造成员变量 m_header，此时会调用Test的构造函数
```

解决方案，**头节点定义为匿名类型**

```c++
//        mutable Node m_header;  // 改成如下
mutable struct : public Object{
	char reserved[sizeof(T)];
	Node* next;
} m_header;
```

---

代码优化：insert，remove，get，set 都涉及元素定位

```c++
 Node* position(int i) const
{
	Node* ret = reinterpret_cast<Node *>(&this->m_header);
	for(int p = 0 ; p< i; ++p)
	{
		ret = ret->next;
	}
	return ret;
}
```

#### 顺序表和单链表的对比分析

查找一个元素，需要增加 `find` 成员函数

在顺序表中

```c++
int SeqList<T>::find(const T& e) const
 {
     for(int i=0; i<this->m_length; ++i)
     {
         if(e == m_array[i])
         {
             return i;    // 返回第一次出现的位置
         }
     }
     return -1;
 }
```

---

在链表中

```c++
template <typename T>
int LinkList<T>::find(const T& e) const  // O(n)
{
    for(int i=0; i<list1.length(); ++i)
    {
        if(e == list1.get(i))
        {
            cout<<"find value at "<<i<<endl;
            return i;    // 返回第一次出现的位置
        }
    }
    return -1;
}
```

---

当查找的是自定义类型，需要依赖与`==`

```c++
class Test3
{
	int val =1;
public:
	Test3(int v = 0) {  val = v; }
};
LinkList<Test3> list3;   // ERROR，编译出错，因为 Test3 没有定义 ==
```

解决方案，顶层父类 增加 `==` 和 `!=` 操作符，自定义类要继承自Object，并重写函数

```c++
class Test3: public Object
{
	int val =1;
public:
	Test3(int v = 0) {  val = v; }
	bool operator== (const Test3& obj) {
	return (val == obj.val);
	}
};
```

---

时间复杂度，`LinkList`的成员函数基本上都是 `O(n)`

| 操作   | SeqList | LinkList |
| ------ | ------- | -------- |
| insert | O(n)    | O(n)     |
| remove | O(n)    | O(n)     |
| set    | O(1)    | **O(n)** |
| get    | O(1)    | **O(n)** |
| find   | O(n)    | O(n)     |
| length | O(1)    | O(1)     |
| clear  | O(1)    | **O(n)** |

`LinkList`的整体时间复杂度较高，但是却更常用

因为，时间复杂度只是效率的一个参考指标

- 对于**内置基础类型**，顺序表和单链表的效率不相上下

- 对于**自定义类型**，**顺序表效率上低于单链表**

以下分析得出的

对于插入和删除（单链表更优）

顺序表：**设计大量数据对象的复制操作**

单链表：只涉及指针操作，效率与数据类型无关

对于数据访问（顺序表更优）

顺序表：随机访问（因为内部实现是原生数组），可直接定位数据对象

单链表：**顺序访问，必须从头访问对象，无法直接定位**

---

工程开发中的选择

选择顺序表的场合

- 数据元素的类型相对简单，不涉及深拷贝

- 数据元素相对稳定，访问操作远多于插入和删除

选择单链表的场合

- 数据元素类型相对较复杂，复制操作相对耗时

- 数据元素不稳定，需要经常插入和删除，访问操作较少



#### 单链表的遍历与优化

==优化一：原始的遍历==

```c++
LinkList<int> list1;
for(int i = 0 ; i<5; ++i)  // O(n)
{
	list1.insert(i*i);
}

for(int i = 0 ; i<list1.length();++i)  // O(n^2)
{
	cout<<"["<<i<<"] = "<<list1.get(i)<<endl;
}
```

新需求：优化使得遍历的复杂度 `O(n)`

思路

- 在单链表内部**定义一个游标** Node* m_current

- 遍历开始前，将游标指向位置0的数据元素

- 获取游标指向的数据元素

- 通过节点中的next指针**移动游标**

提供一组遍历相关的函数，实现`O(n)`

| 函数      | 描述                           |
| --------- | ------------------------------ |
| move()    | 将游标定位到目标位置           |
| next()    | 移动游标                       |
| current() | 获取游标所指向的数据元素       |
| end()     | 游标是否到达尾部（即是否为空） |

```c++
bool move(int i, int step = 1);
bool end();
T current();
bool next();

// 使用，四个函数需要相互依赖，配合
for(list1.move(0); !list1.end(); list1.next())  // 复杂度降为 O(n)
{
	cout<<"list1.current"<<list1.current()<<endl;
}
```

---

==优化二：单链表内部的一次封装==

```c++
virtual Node* create()
{
	return new Node();
}
virtual void destory(Node* pn)
{
	delete pn;
}
```

在`new` 和 `delete`的地方都用 `create()`和 `destory()`代替

> 意义：增强扩展性
>
> 为静态单链表的实现做准备，StaticLinkList与LinkList的不同仅仅在于链表节点内存分配上的不同。因此，将仅有的不同封装于父类和子类的虚函数中



### 静态单链表的实现

==单链表的一个缺陷==

触发条件：长时间使用单链表对象频繁增加和删除数据元素（会创建对象和释放）

可能导致堆空间产生大量**内存碎片**，导致系统**运行缓慢**

---

方案：顺序表 + 单链表 = 静态单链表

在“单链表”的内部增加一片预留空间，所有的 `Node` 对象都在这片空间中动态创建和销毁

因此，只需要修改` virtual Node* create() `和 `virtual void destory(Node* pn)`

- 通过模板定义`StaticLinkList` ，继承自 `LinkList`

- 在类中定义固定大小的空间 （`unsigned char []`）

- 重写` create()` 与  `destory()`，改变内存的分配和归还方式

- 在 `Node` 类中重载 `operator new` ，用于在指定内存上创建对象

静态单链表适合于频繁增删数据元素的场合（最大元素个数固定）

```c++
template <typename T, int N>
class StaticLinkList : public LinkList<T>
{
  protected:
    typedef typename LinkList<T>::Node Node;
    struct SNode : public Node
    {
        void* operator new (long unsigned int size_t, void* loc)
        {
            return loc;
        }
    };
    typedef typename StaticLinkList<T, N>::SNode SNode;

    unsigned char m_space[sizeof( SNode)* N];
    int m_used[N];

    void destory(Node* pn) override;
    SNode* create() override;

public:
    StaticLinkList();
    int capacity();

};
```

问题：创建了 `StaticLinkList` 对象，程序结束时报错，`free(): invalid pointer` 









## Bugfix

ISSUE 1

创建一次对象时的空指针问题

```c++
try
{
	IndexOutOfBoundsException npe;   // 情况一
//	IndexOutOfBoundsException npe("error");  // 情况二
//	IndexOutOfBoundsException npe("error"，__FILE__, __LINE);  // 情况三
	cout<<"throw"<<endl;
	throw npe;
}
catch(const Exception& e)
{
	cout<<"catch:"<<endl;
}
```

运行结果，情况一和二都是 只打印 `throw` ，情况三打印` throw catch`

```c++
 m_message = strdup(message);   
 // 修改为
m_message = (message == nullptr)?nullptr:strdup(message);
m_message = (e.m_message == nullptr)?nullptr:strdup(e.m_message);
m_location = (e.m_location == nullptr)?nullptr : strdup(e.m_location);
```



---





```c++
class Test3: public Object
{
	int val =1;
public:
	Test3(int v = 0) {  val = v; }
	bool operator== (const Test3& obj) {
	return (val == obj.val);
	}
	~Test3()
	{
		if(val == 1)
		{
			throw m_id;
		}
    }
};

    LinkList<Test3> list;
    Test3 t0(1), t1(1), t2(2);
    try
    {
        list.insert(t0);
        list.insert(t1);
        list.insert(t2);
        list.remove(1);  // 会调用 Test3的析构函数，而在析构函数中抛出异常 1
    }
    catch(...)
    {
        cout<<"catch:"<<list.length()<<endl;
    }
```

Qt环境下，不允许在析构函数中抛出异常，就算抛出了也无法捕获









## 再论智能指针

使用智能指针替换 `LinkList` 中的原生指针

直接替换，并删除destory()，ERROR，因为一片堆空间最多只能由一个指针标识

解决方案：设计了 `SharedPointer`

步骤一：创建智能指针的抽象父类 Pointer

- 纯虚析构函数 virtual ~Pointer() = 0;

- 重载 operator-> ();

- 重载 operator* ();

```c++
template <typename T>
class Pointer : public Object
{
protected:
T* m_pointer;
public:
	Pointer(T* p = nullptr);
	T* operator-> ();
	T& operator* ();
	bool isNull();
	T* get();
};
```

步骤二：`SmartPointer` 和 `SharedPointer` 都继承自 `Pointer`

---

`SharedPointer` 需求

通过计数机制（ref）标识堆内存，堆内存被指向时（ref++），指针被置空时（ref--），ref==0时（释放堆内存）

多个智能指针对象可以指向同一片堆空间，只自动释放一次

由于支持多个对象同时指向同一片堆空间，因此，必须支持比较操作

```c++
template <typename T>
class SharedPointer: public Pointer<T>
{
protected:
	int* m_ref;  // 计数机制成员指针，用来保存计数值
public:
	SharedPointer(T* p = nullptr);
	SharedPointer(const SharedPointer<T>& obj);
	
	SharedPointer<T>& operator= (const SharedPointer<T>& obj);
	
	void clear();  // 将当前指针置为空
	~SharedPointer();
};
```

智能指针的军规

- 只能使用智能指针指向堆空间中的单个对象

- 不同类型的智能指针对象不能混合使用

- 不要使用 delete 释放智能指针指向的堆空间

---

Bug

```c++
const SharedPointer<Test4> sp5 =  new Test4(666);
sp5->value = 9000;  // ERROR
sp5=sp1;   // ERROR
```

解决方案

```c++
template <typename T>
const T* Pointer<T>::operator-> () const
{
    return m_pointer;
}

template <typename T>
const T& Pointer<T>::operator* () const
{
    return *m_pointer;
}
```















## 循环链表







## 双向链表





## Linux的两个宏







## Linux内核链表剖析







## 双向循环链表实现







## 栈

一种特殊的线性表，仅能在线性表的一端进行操作，**后进先出** `Last in first out`

栈顶 `Top` ：允许操作的一端

栈底 `Button` ：不允许操作的一端

==基本操作==

> 创建、销毁、清空 `clear()` 、出栈 `pop()` 、入栈 `push()` 、获取栈顶元素 `top()`、获取栈大小 `size()`

> 类设计：Object（父类），Stack（抽象父类StaticStack、LinkStack（Stack的子类）

```c++
template < typename T>
class StackM: public Object
{
public:
	virtual void push(const T& e) = 0;
	virtual void pop() = 0;
	virtual T top() const = 0 ;
	virtual void clear() = 0 ;
	virtual int size() const = 0;
};
```

---

#### StaticStack

- 类模板，使用原生数组作为栈的存储空间

- 使用模板参数决定栈的最大容量

```c++
template <typename T, int N>
class StaticStack: public StackM<T>
{
protected:
	T m_space[N];  // 栈存储空间
	int m_top;    // 栈顶标识
	int m_size;    // 当前栈大小
public:
	StaticStack();
	int capacity() const;
	...
};
```

---

==缺陷==

```c++
class Test3: public Object
{
public:
	Test3() {  cout<<"test3"<<endl; }

	~Test3()
	{
		cout<<"~test3"<<endl;
	}
};
StaticStack<Test3,10> sta2;  // 会调用 Test3 的构造函数 10 次
cout<<sta2.size()<<endl;
```

==问题原因==

使用了原生的数组作为存储空间，`T m_space[N];`  因此创建 `StaticStack` 对象时，会调用T的构造函数

==解决方案==

链式栈 `LinkStack` 的存储实现

#### LinkStack

- 类模板，继承自 `Stack`

- 在内部组合使用 `LinkList` ，实现栈的链式存储

- 只在单链表成员对象的头部进行操作

```c++
template <typename T>
class LinkStack: public StackM<T>
{
protected:
    LinkList<T> m_list;
public:
    void push(const T& e) override;
    void pop() override;
    T top() const override ;
    void clear() override ;
    int size() const override;
};
```

---

==栈的应用实践==

栈“后进先出”特性适用于检测成对出现的符号，适合于需要“就近匹配”的场合

成对出现的符号，成对检测问题

括号：(), [] , {} , <>

引号： ‘’   “”  

---

==算法思路==

- 从第一个字符开始扫描

- 当遇到普通字符时忽略

- 当遇到左符号时压栈

- 当遇到右符号时弹出栈顶符号，并进行匹配

结束

- 成功：所有字符扫描完毕，且栈为空

- 失败：匹配失败或所有字符扫描完毕但栈非空









## 队列 Queue

队列是一种特殊的线性表，先进先出  `first in first out`

仅能在线性表的两端进行操作，尾端进，首端出

队头 `front` ：取出元素的一端

队尾 `rear` ：插入元素的一端



> 操作：创建，销毁、清空 `clear`、进队列 `add`、出队列 `remove`、获取头元素 `front`、获取长度` length`
>
> 类设计：`Queue`（抽象父类），`StaticQueue` 与 `LinkQueue`



```c++
template <typename T>
class Queue: public Object
{
public:
	virtual void add(const T& e) = 0;
	virtual void remove() = 0;
	virtual T front() const = 0;
	virtual void clear() = 0;
	virtual int length() const = 0;
};
```



#### StaticQueue

- 类模板，使用原生数组作为队列的存储空间

- 使用模板参数决定队列的最大容量

```c++
template <typename T , int N>
class StaticQueue : public Queue<T>
{
protected:
	T m_space[N];  // 队列存储空间
	int m_front;  // 队列顶标识
	int m_rear;   //  队列尾标识
	int m_length;  // 当前长度
public:
	StaticQueue();
	int capacity() const;
	...
};
```



---

关键操作（**循环计数法**）

（1）进队列

```c++
m_space[m_rear] = e;
m_rear = (m_rear +1 )%N;
```

（2）出队列

```c++
m_font = (m_font + 1) %N;
```

判断队列的状态

（3）队空

```c++
(m_length == 0) && (m_front == m_rear)
```

（4）队满

```c++
(m_length == N) &&( m_front == m_rear)
```



---

缺陷

和 `StaticList` 一样，当 `StaticQueue` 的对象是类类型时，创建 `StaticQueue` 时会调用其构造函数

解决方案

**链式存储结构**

两个指针：front指向队头

rear指向队尾







#### LinkQueue



- 类模板，在内部使用链式结构实现元素的存储

- 只在链表的头部和尾部进行操作

参考 `LinkStack` 的实现，`LinkQueue` 将 `LinkList` 作为成员变量

```C++
template<typename T >
class LinkQueue : public Queue<T>
{

protected:
    LinkList<T> m_list;   // 队列存储空间

public:
    LinkQueue();
    void add(const T& e) override;
    void remove() override;
    T front() const override;
    void clear() override;
    int length() const override;
};
```



时间复杂度对比

|          | StaticQueue | LinkQueue |
| -------- | ----------- | --------- |
| add()    | O(1)        | **O(n)**  |
| remove() | O(1)        | O(1)      |
| front()  | O(1)        | O(1)      |
| clear()  | O(1)        | **O(n)**  |
| length() | O(1)        | O(1)      |

---

`LinkList` 优化，`add()` 可优化

优化方式：双休循环链表

使用 `Linux` 内核链表，`LinuxList`



==37-2==









## 两个有趣问题

==Q1==：栈（后进先出）和队列（先进先出）实现上类似，是否可用栈实现队列

两个栈实现队列，一个栈 stack_in 用于进入，一个栈 stack_out 用于出

当有新元素入队时，将其压入 stack_in

当需要出队时

- stack_out .size() == 0

  （1）将 stack_in 中的元素逐一压入 stack_out

  （2）将 stack_out 的栈顶弹出

- stack_out .size() > 0

  将 stack_out 的栈顶弹出

两个栈实现队列复杂度对比

|          | StackToQueue | LinkQueue |
| -------- | ------------ | --------- |
| add()    | O(1)         | **O(n)**  |
| remove() | O(n)         | O(1)      |
| front()  | O(n)         | O(1)      |
| clear()  | O(n)         | **O(n)**  |
| length() | O(1)         | O(1)      |

`StackToQueue` 复杂度更高



个人疑问

```C++
T front() const // const函数里面只能调用 const 函数，如果想要调用非const 函数，就需要把成员变量声明为 mutable

virtual T front() const = 0;  // 父类
T front() const override    // 子类，如果要修改成员变量，就需要把成员变量声明为 mutable
// 为什么不能定义 T front() 
```

---

==Q2==：用两个队列实现栈，`QueueToStack`

实现思路，queue_1 与 queue_2

当有新元素入栈时，将其加入 queue_1

当需要出栈时

- 将队列 `queue_1` 中的 `n-1`个元素出队列，并进入 `queue_out` 中

- 将队列 `queue_1` 的最后一个元素出队列（出栈）

- 交换两个队列的角色

时间复杂度

|         | QueueToStack | LinkStack |
| ------- | ------------ | --------- |
| push()  | O(1)         |           |
| pop()   | O(n)         |           |
| top()   | O(n)         |           |
| clear() | O(n)         |           |
| size()  | O(1)         |           |

`QueueToStack` 的复杂度高

---

总结：栈和队列实现相似，可以相互转化



## 字符串类

C 语言不支持真正意义上的字符串，用的是字符数组和一组函数模拟字符串操作

C 语言不支持自定义类型，因此无法获得字符串类型



c → C++的进化过程引入了自定义类型，在C++中可以通过类完成字符串类型的定义

> 类设计：String（抽象父类），	



```C++
class String: public Object
{
protected:
	char* m_str;
	int m_length;
	void init(const char* s);
public:
	String();
	String(const char* s);
	String (const String & s);
    String(char c);
    int length() const;
    const char* str() const;
    
    /* 比较操作符重载 */
     /* 加法操作符重载 */
      /* 赋值操作符重载 */
    
    ~String();
}
```



==注意==

需要无缝实现` String` 对象与 `char*` 字符串的互操作

操作符重载函数需要考虑是否支持 `const` 版本

通过 `C` 语言中的**字符串函数**（如 `strdup()`、`strlen()`、`strcpy()`、`strcat()` ）实现 `String` 的成员函数

---

字符串常用成员函数

| 成员函数        | 功能                  |
| --------------- | --------------------- |
| `operator[](i)` | 访问指定下标的字符    |
| `startWith(s)`  | 判断字符串是否以s开头 |
| `endOf(s)`      | 判断字符串是否以s结尾 |
| `insert(i,s)`   | 在字符串的位置i插入s  |
| `trim()`        | 去掉字符串两端的空格  |

---

重载数组操作符 []

```C++
char& StringM::operator[] (int i)
{
    if( (0<= i) && (i<m_length) )
    {
        return m_str[i];
    }
    else
    {
        THROW_EXCEPTION(IndexOutOfBoundsException, "parameter i is out of bounds...");
    }
}
char StringM::operator[] (int i) const
{
    return (const_cast<String &>(*this)[i]);
}
```

判断是否以指定字符开始/结束

```C++
bool startWith(const char* s) const;
bool startWith(const String& s) const;
bool endOf(const char* s) const;
bool endOf(const StringM & s) const;
```

在指定位置处插入字符串

```C++
StringM& intsert(int i, const char* s);
StringM& insert(int i, const StringM& s);
```

去掉字符串两端的空白字符

```c++
String& trim();
```





## KMP 子串查找算法

如何在目标字符串中查找是否存在指定的子串

```c++
StringM s = "zzh test";
int pos = s.indexOf("test");  // 4
```















### KMP 算法的应用











## 递归

排序和树中都用到了递归

采用数学上分而治之的思想，如数学归纳法

- 将原问题分解成规模较小的问题进行处理

- 分解后的问题与原问题的类型完全相同，但规模更小

- 问题的分解是有限的，递归不能无限进行



==递归函数==

- 函数体中存在自我调用的函数

- 递归函数必须有递归出口（**边界条件**）

- 函数的无限递归将导致出现崩溃



---

**事例一**：递归解 `Sum(n) = 1 + 2 + 3 + ... + n`

```C++
unsigned int sum(unsigned int n)
{
	if(n>1)
	{
		return n + sum(n-1);
	}
	else
	{
		return 1;
	}
}
```

---

**事例二**：斐波那契数列

定义：1,1,2,3,5,8,13,21

特点：1,1，后面的项是前两项之和

```c++
unsigned int fac(unsigned int n)
{
	if(n>2)
	{
		return fac(n-1)+fac(n-2);
	}
	if( 2== n  || 1== n)
	{return 1;}
}
```

---

使用递归求字符串长度，递归模型

```c++
unsigned int strlenM(const char* s)
{
	if(*s != '\0' )
    {
        return 1+ strlen(s+1);
    }
    else
    {
        return 0;
    }
    // return s ? ( (*s =='\0')? 0: (1+strlen(s+1)) ) : 0;  // 或直接
    // return s ? ( (*s ) ? (1+strlen(s+1)) :0  ) : 0; 
}
```

用递归解决问题，首先建立递归模型。必须有边界条件，否则无解



---

**递归的应用一**：单向链表的逆转

```c++
reverse(list)
(1)当 list == nullptr:    nullptr
(2)当 len(list) == 1		list
(3)当 len(list)>=2			
{
    guard = list->next;
    ret = reverse(list->next);
    guard->next = list;
    list->next = nullptr;
}
```



具体见 Video 44-1

---

**递归的应用二**：单向排序链表的合并







---

**递归的应用三**：汉诺塔问题

```C++
void HanoiTower(int n, char a, char b, char c)  // a:source, b:destination , c:tool
{
    if( n == 1)
    {
        cout<<a<<"-->"<<c<<endl;
    }
    else
    {
        HanoiTower(n-1,a,c,b);
        HanoiTower(1,a,b,c);
        HanoiTower(n-1,b,a,c);
    }
}
```



---

**递归的应用四**：全排列

如：{ a，b，c } 的全排列， abc，acb，bac，bca，cab，cba



















## 排序

将无序的一组数据调整为有序的数据元素

排序的稳定性，如

num3 = 3， num1 = 1， num2 = 1， 

稳定的排序： num1， num2， num3

不稳定的排序： num2， num1， num3

---

多关键字比较与单关键字比较 复杂度一样

```C++
struct TestVideo46_2: public Object
{
    int key1;
    int key2;
    TestVideo46_2(int k1, int k2):key1(k1),key2(k2){}
    bool operator== (const TestVideo46_2& t)
    {
        return ( (key1== t.key1)&& (key2 == t.key2) );
    }
    bool operator!= (const TestVideo46_2& t)
    {
        return !(*this == t);
    }
    bool operator < (const TestVideo46_2& t)
    {
        return ( (key1<t.key1)||( (key1==t.key1) &&(key2<t.key2)) );  // key1 的比较优先级更高
    }
    bool operator>= (const TestVideo46_2& t)
    {
        return (!(*this< t) );
    }
    bool operator > (const TestVideo46_2& t)
    {
        return ( (key1>t.key1)||( (key1==t.key1) &&(key2>t.key2)) );  // key1 的比较优先级更高
    }
    bool operator<= (const TestVideo46_2& t)
    {
        return (!(*this> t));
    }
};
```

---

排序中的关键操作

比较：任意两个数据的比较

交换：交换位置

---

==排序选择标准==

时间性能：比较和交换的次数

辅助存储空间：必要时“空间换时间”

算法的实现复杂度：过复杂的算法影响可读性和可维护性

> 类设计：SortM

```C++
class SortM: public Object
{
private:
	SortM();  // 说明不可能创建对象，可以调用static 函数
	SortM(const SortM&);
	SortM& operator= (const SortM&);
	
	template <typename T>
	static void Swap(T& a, T& b)
	{
		T c(a);
		a =b; 
		b= c;
	}
public:
};
```





### 选择排序和插入排序

==选择排序==

基本思想：每一次（如第 i 此）从后面 n-i 个待排序元素中选出关键字最小的元素，作为有序元素序列第 i 个元素

```C++
template <typename T>
    static void SelectSort(T array[], int len, bool min2max = true)  // default: min to max
    {
        for(int i = 0; i < len; ++i)
        {
            int min = i;
            for(int j = i+1 ; j< len; ++j)
            {
                if( min2max ? (array[min] > array[j]) :  (array[min] < array[j]) )
                {
                    min = j;
                }
            }
            if(i != min)
            {
                Swap(array[i], array[min]);
            }
        }
    }
```

选择排序不稳定，因为每次交换时会打破原有的顺序

==插入排序==

基本思想：当要插入第i（i≥1）个数据元素时，前面的 i-1 个元素已排好序。这时，找到数据应该插入的位置并插入



```C++
template <typename T>
    static void InsertSort(T array[], int len, bool min2max = true)  // default: min to max
    {
        for(int i = 0 ; i <len ; ++i)
        {
            int k = i;
            T e  = array[i];
            for(int j = i-1; (j>=0) && ( min2max ? (array[j] > e) : (array[j] < e) ); --j)
            {
                array[j+1] = array[j];
                k = j;
            }
            if(k!= i)
            {
                array[k] = e;
            }
        }
    }
```



插入排序是稳定的，选择排序和插入排序的复杂度为 `O(n^2)`



### 冒泡排序和希尔排序

==冒泡排==

基本思想：每次**从后向前**进（如第 i 次），与 j = n-1，n-2，...，i；两两比较。如果发生逆序，则交换两个数的位置 



```C++
template <typename T>
    static void BubbleSort(T array[], int len, bool min2max = true)  // default: min to max
    {
        bool exchangeFlag  = true;
        for(int i = 0 ; (i <len) && exchangeFlag; ++i )
        {
            exchangeFlag = false;
            for(int j = len -1; j>i ;j--)
            {
                if(  min2max ? (array[j] < array[j-1]) :  (array[j] > array[j-1]))
                {
                    Swap(array[j],array[j -1]);
                    exchangeFlag = true;
                }
            }
        }
    }
```

时间复杂度：O(n^2)



==希尔排序==

选择排序、插入排序、冒泡排序的复杂度都是 `O(n^2)`

基本思想：将待排序序列划分为若干组，在每一组内进行插入排序，以使得整个序列基本有序，然后再对整个序列进行插入排序

通过分组的方式进行多次插入排序

使用插入排序作为基本排序方法

d 为间隔



```C++
 template <typename T>
    static void ShellSort(T array[], int len, bool min2max = true)  // default: min to max
    {
        int d = len;
        do
        {
            d = d/3 + 1;  // or d--

            for(int i = d; i<len; i+=d)
            {
                int k = i;
                T e  = array[i];
                for(int j = i-d; (j>=0) && ( min2max ? (array[j] > e) : (array[j] < e) ); j-=d)
                {
                    array[j+d] = array[j];
                    k = j;
                }
                if(k!= i)
                {
                    array[k] = e;
                }
            }
        }while ( d > 1);
```

希尔排序是不稳定的，复杂度为 O(^1.5)









### 归并排序和快速排序



==归并排序==

将两个或两个以上的有序序列合并成一个新的有序序列

有序序列 V[0]、...V[m] 与 V[m+1]、...V[n-1] 

合并为 V[0]、...V[n-1]

称为2路归并

同理，将N个有序序列归并为一个新的有序序列，称为 N 路归并





```c++
template <typename T>
    static void MergeSort(T src[], T helper[],int begin,int mid, int end, bool min2max = true)  // default: min to max
    {
        int i = begin;
        int j = mid+1;
        int k = begin;
        while( (i<= mid) && (j<=end) )
        {
            if( min2max ? (src[i] < src[j]) : (src[i] > src[j]) )
            {
                helper[k] = src[i];
                k++;
                i++;
            }
            else
            {
                helper[k] = src[j];
                k++;
                j++;
            }
        }

        while( i<= mid)
        {
            helper[k] =src[i];
            k++;
            i++;
        }
        while( j<= end)
        {
            helper[k] =src[j];
            k++;
            j++;
        }

        for(i = begin; i<=end; ++i)
        {
            src[i] = helper[i];
        }
    }

    template <typename T>
    static void MergeSort(T src[], T helper[],int begin, int end, bool min2max = true)  // default: min to max
    {
        if(begin < end)
        {
            int mid = (begin + end)/2;
            MergeSort(src,helper,begin,mid,min2max);
            MergeSort(src,helper,mid+1,end,min2max);
            MergeSort(src,helper,begin,mid,end,min2max);
        }
    }

template <typename T>
    static void MergeSort(T array[], int len, bool min2max = true)  // default: min to max
    {
     T* helper = new T(len);
     if(helper != nullptr)
     {
        MergeSort(array,helper,0,len-1,min2max);
     }
     delete[] helper;
    }
// 使用
SortM::MergeSort(arr,len,false);  // 从大到小排序
```









==快速排序==



基本思想：

-- 任意序列中的某个数据元素作为基准将整个序列划分为左右两个子序列

- 左侧子序列中所有元素都 >= 基准元素

- 右侧子序列中所有元素都 <= 基准元素

- 基准元素排在这两个子序列中间

-- 分别对这两个子序列重复进行划分（即对无序子序列进行快速排序），直到所有数据元素都排在相应位置上为止





```C++
template <typename T>
    static int Partition(T array[], int begin, int end, bool min2max = true)
    {
        T pv = array[begin];
        while( begin < end)
        {
             while( (begin < end) && ( min2max ? (array[end] > pv) : (array[end] < pv ))  )
            {
                end--;
            }
            Swap(array[begin], array[end]);
            while(begin < end && ( min2max ?  (array[begin] <= pv) : (array[begin] >= pv) ) )
            {
                begin ++;
            }
            Swap(array[begin], array[end]);
        }
        array[begin] = pv;
        return begin;
    }

    template <typename T>
    static void QuickSort(T array[], int begin,int end, bool min2max = true)  // default: min to max
    {
        if(begin < end)
        {
            int  pivot = Partition(array,begin,end,min2max);
            QuickSort(array,begin,pivot-1,min2max);
            QuickSort(array,pivot+1,end,min2max);
        }
    }

    template <typename T>
    static void QickSort(T array[], int len, bool min2max = true)  // default: min to max
    {
        QuickSort(array,0,len-1,min2max);
    }
    
// 使用
SortM::QickSort(arr,len,false);
```



小结

- 归并排序需要额外的辅助空间才可完成，空间复杂度为 `O(n)` ，时间复杂度为 `O(n*logn)` ，是稳定的

- 快速排序通过**递归**的方式对排序问题进行划分，时间复杂度为 `O(n*logn)` ，是不稳定的



### 排序的工程应用



|            | 选择排序 | 插入排序 | 冒泡排序 | 希尔排序 | 归并排序 | 快速排序 |
| ---------- | -------- | -------- | -------- | -------- | -------- | -------- |
| 时间复杂度 |          |          |          |          |          |          |
| 空间复杂度 |          |          |          |          |          |          |
| 是否稳定   |          |          |          |          |          |          |



---

**应用一**：排序类 SortM 与数组类 Array 的关系

如何使得能对 Array 进行排序

解决方法：

ArrayM 中增加

```c++
T* array()
```

SortM 中增加

```c++
template <typename T>
static void SelectSort(ArrayM<T>& ar, bool min2max = truer)
{
	SelectSort(arr.array(), arr.length(), min2max);  // default: min to max
}
static void BubbleSort(ArrayM<T>& arr, bool min2max = true);
static void InsertSort(ArrayM<T>& ar, bool min2max = truer);
static void ShellSort(ArrayM<T>& arr, bool min2max = true);
static void MergeSort(ArrayM<T>& arr, bool min2max = true);
static void QuickSort(ArrayM<T>& arr, bool min2max = true);
```



---

应用二：当待排序元素为庞大的对象时，如何提高排序的效率

```c++
struct Test: public Object
{
	int id;
	int data1[1000];
	double data2[500];
};
Test t[1000];
SortM::Bubble(t,1000);
```



---

排序过程中不可避免的操作：交换操作

交换操作，本质是数据元素间的相互复制

当数据元素体积较大时，**交换操作耗时巨大**

解决方案：==代理模式==

1. 为待排序元素设置代理对象
2. 对代理对象所组成的序列进行排序
3. 需要访问有序数据元素时，通过访问代理序列完成



```c++
struct Test: public Object
    {
        int id;
        int data1[1000];
        double data2[500];
        bool operator< (const Test& obj)
        {
            return (this->id < obj.id);
        }
        bool operator>= (const Test& obj)
        {
            return !(this->id < obj.id);
        }
        bool operator> (const Test& obj)
        {
            return (this->id > obj.id);
        }
        bool operator<= (const Test& obj)
        {
            return !(this->id > obj.id);
        }


    };


    class TestProxy: public Object
    {
          protected:
        Test* m_pTest;
        public:
//        TestProxy(Test* pTest)
//        {
//            m_pTest = pTest;
//        }
        int id()
        {
            return m_pTest->id;
        }
        int* data1()
        {
            return m_pTest->data1;
        }
        double* data2()
        {
            return m_pTest->data2;
        }
        Test& test() const
        {
            return *m_pTest;
        }

        bool operator< (const TestProxy& obj)
        {
            return test() < obj.test();
        }
        bool operator>= (const TestProxy& obj)
        {
            return test() >= obj.test();
        }
        bool operator> (const TestProxy& obj)
        {
            return test() > obj.test();
        }
        bool operator<= (const TestProxy& obj)
        {
            return test() <= obj.test();
        }
        Test& operator= (Test& test)
        {
            m_pTest = &test;
            return test;
        }

    };

    int len = 1000;
    Test t[len];
    TestProxy pt[len];

    for(int i = 0; i<len; ++i)
    {
        t[i].id  = i;
        pt[i] = t[i];
    }

    clock_t begin = 0,end = 0;
//    begin = clock();
//    SortM::BubbleSort(t,len,false);
//    end = clock();
//    cout<<"time:"<<(end - begin)<<endl;

    begin = clock();
    SortM::BubbleSort(pt,len,false);
    end = clock();
    cout<<"time:"<<(end - begin)<<endl;
```

问题，对代理进行排序，代理中的数据元素排序了，但是t里面的数据未排序

---

当排序体积庞大的对象时，使用代理模式间接完成

代理模式的使用有效避开大对象交换时的耗时操作，效率提高100倍

代理模式解决方案是空间换时间的体现





## 树

一种非线性数据结构

树是由 `n(n>=0)` 个节点组成的有限集合

如果 `n=0` ，称为空树

如果 `n>0` ，则

- 有一个特定的称为根 `root` 的节点

- 根节点只有直接后继，但没有直接前驱

- 除根以外的其他节点划分为 `m(m>=0)` 个互不相交的有限集合 `T0，T1，...，T（m-1）` ，每个集合又是一颗树，并且称之为根的子树 `sub tree`

---

树中度的概念

**树节点包含一个数据及若干指向字树的分支**

节点拥有的子树数目称为节点的度

- 度为0的节点称为叶节点

- 度不为0的称为分支节点

**树的度定义为所有节点中度的最大值**

---

**树中前驱和后继**

节点的直接后继称为其孩子，相应的该节点称为孩子的双亲

节点的孩子的孩子称为其子孙

同一个双亲的孩子之间称兄弟

树节点拥有一个唯一前驱（父节点），和若干个后继（子节点）

---

树中节点的最大层次称为树的深度或高度

---

**树的有序性**：如果树中节点的各子树从左向右是有序次的，子树间不能互换位置，则称该树为有序树，否则为无序树

---

**森林**：由 `n(n>=0)` 棵互不相交的树组成的集合

---

树的常用操作

将元素插入、删除，获取树的节点，获取树高度，获取树的度，清空树

> 类设计：

```C++
template <typename T>
class Tree: public Object
{
protected:
	TreeNode<T>* m_root;
public:
	Tree() { m_root = nullptr; }
	virtual bool insert(TreeNode<T>* node ) = 0;
	virtual bool insert(const T& value, TreeNode<T>* parent) = 0;
	virtual SharedPointer<Tree<T> > remove(const T& value) = 0;
	virtual SharedPointer<Tree<T> > remove(TreeNode<T >* node) = 0;
	virtual TreeNode<T>* find(const T& value) const  =0;
	virtual TreeNode<T>* find(TreeNode<T>* node ) const =0;
	virtual TreeNode<T>* root() const = 0;
	virtual int degree() const = 0;
	virtual int count() const = 0;
	virtual int height() const = 0;
	virtual void clear() = 0;
};
```

树的节点也表现为一种特殊的数据类型

```c++
template <typename T>
class TreeNode: public Object
{
public:
	T value;
	TreeNode<T>* parent;
	TreeNode()
	{
		parent = nullptr;
	}
	virtual ~TreeNode() = 0;  // 抽象类
};
```



### 树的存储结构与实现

树和节点的存储结构

`GTreeNode` 能够包含**任意多**指向后继节点的指针

```c++
template <typename T>
class GTreeNode : public TreeNode<T>
{
	public: LinkList<GTreeNode<T>*> child;
};
```

`GTree` 为通用树结构，每个节点可以存在多个后继节点

```c++
template <typename T>
class GTree : public Tree<T>
{
	// 实现虚函数
};
```



每个数节点中为什么要包含指向前驱节点的指针

从根节点→叶节点：非线性数据结构

从叶节点→根节点：线性数据结构（链表）





### 树中节点的查找

查找方式

——基于数据元素值 `GTreeNode<T>* find(const T& value) const`

```c++
 template <typename T>
 GTreeNode<T>* GTree<T>::find(GTreeNode<T>* node,const T& value) const  // 在 node 为根节点的树中查找 value 所在的节点
 {
    GTreeNode<T>* ret = nullptr;
    if(node!=nullptr)
    {
        if(node->value == value)
        {
            return node;
        }
        else
        {
            for(node->child.move(0); !node->child.end() && (ret == nullptr); node->child.next())
            {
                find(node->child.current(),value);

            }
        }
    }
    return ret;
 }

template <typename T>
 GTreeNode<T>* GTree<T>::find(const T& value) const
{
    return find(root(),value);
}

```

——基于节点  `GTreeNode<T>* find(TreeNode<T>* node) const`

```c++
template <typename T>
 GTreeNode<T>* GTree<T>::find(GTreeNode<T>* node,GTreeNode<T>* obj) const
 {
     GTreeNode<T>* ret = nullptr;
     if(node == obj)
     {
         return obj;
     }
     else
     {
         if(node!= nullptr)
         {
             for(node->child.move(0); !node->child.end() && node==nullptr; node->child.next)
             {
                 find(node->child.current(),obj);
             }
         }
     }
     return ret;
 }

 template <typename T>
 GTreeNode<T>* GTree<T>::find(TreeNode<T>* node ) const
{
     return find(root(),node);
}
```

插入和删除操作都依赖于查找



### 树中节点的插入

如何确定插入的位置

树是非线性的，无法采用索引的形式定位数据元素

每一个数节点都有唯一的前驱节点

因此，必须**先找到前驱节点**，才能完成新节点的插入

---

插入方式

—— 插入新节点  `bool insert(TreeNode<T>* node ) `

```C++
template <typename T>
 bool GTree<T>::insert(TreeNode<T>* node )
{
    bool ret = true;
    if(node!= nullptr)
    {
        if(this->m_root != nullptr)
        {
            node->parent = nullptr;
            this->m_root = node;
        }
        else
        {
            GTreeNode<T>* np = find(node->parent);
            if(np != nullptr)
            {
                GTreeNode<T>* n = dynamic_cast<GTreeNode<T>*>(node);
                if(np->child.find(n) < 0)
                {
                    np->child.insert(n);
                }
            }
            else
            {
                THROW_EXCEPTION(InvalidOperationException,"invalid parent tree node...");
            }
        }
    }
    else
    {
        THROW_EXCEPTION(InvalidParameterException,"paramater node cannot be nullptr...");
    }
    return ret;
}
```



——插入数据元素 `bool insert(const T& value, TreeNode<T>* parent) `

```C++
template <typename T>
bool GTree<T>::insert(const T& value, TreeNode<T>* parent)
{
    bool ret = true;
    GTreeNode<T>* node = new GTreeNode<T>();
    if(node != nullptr)
    {
        node->value = value;
        node->parent = parent;
        insert(node);
    }
    else
    {
        THROW_EXCEPTION(NoEnoughMemoryException,"no enough memory to create tree node...");
    }
     return ret;
}
```



- 插入操作是构建树的唯一操作

- 指向插入时**必须指明**节点间的父子关系

- 插入操作**必须正确处理**指向父节点的指针

- 插入数据元素时需要从**堆空间**中创建节点







### 树中节点的清除



——virtual void clear()  将树中的所有节点清除（释放堆中的节点），使用递归

```C++
template <typename T>
void GTree<T>::free(GTreeNode<T>* node)
{
    if(node != nullptr)
    {
        for(node->child.move(0);!node->child.end();node->child.next())
        {
            free(node->child.current());
        }
        delete node;
    }
}

template <typename T>
void GTree<T>::clear()
{
    free(root());
    this->m_root = nullptr;
}
```

---

存在问题：当插入的节点是存储在栈上时，运行 `clear()` 会报错

```c++
    GTree<char>  t2;
    GTreeNode<char> root;
    root.value ='A';
    root.parent = nullptr;

   	t2.insert(&root);  // 根节点是局部变量，存储在栈上
	t2.clear();
```

问题分析

- 树中的节点可能来源于不同的存储空间，**如何判断堆空间中**的节点并释放
- 单凭内存地址很难准确判断具体的存储空间

- 只有堆空间的内存需要主动释放 delete

- 清除操作时只需要对堆中的节点进行释放

解决方案：**工厂模式**

1. 在 `GTreeNode` 中增加保护成员变量 `m_flag`
2. 将 `GTreeNode` 中的 `operator new` 重载为保护成员函数
3. 提供工厂方法 `GTreeNode<T>* NewNode()`  用于在类外部来 new 出对象
4. 在工厂方法中 `new` 新节点并将 `m_flag` 设置为 `true`

```c++
GTreeNode<int>* hn = GTreeNode<int>::NewNode();
GTreeNode<int> sn;
if(hn->flag())  // true 是堆空间中的
{
	delete &hn;
}
hn = &sn;
if(hn->flag)  // false 
{
	delete hn;
}
```

工厂模式可用于定制堆空间中的节点，只有销毁定制节点的时候需要释放



### 树中节点的删除

设计要点

- 将被删除节点所代表的子树进行删除

- 删除函数返回一棵堆空间中的树

- 返回值为指向树的 `SharedPointer`，即被删除的树，这样可以将被删除的树重新利用

技巧：当需要从函数中返回堆中的对象时，使用智能指针 `SharedPointer` 作为返回值



——基于数据元素值的删除，`virtual SharedPointer<Tree<T>> remove(const T& value) ;`

```
void remove(GTreeNode<T>* node, GTree<T>*& ret)   // ret 是一个指针的引用
// 将node为根节点的子树删除，ret作为子树返回
```













——基于节点，`virtual SharedPointer<Tree<T>> remove(TreeNode<T>* node) ;`







### 树中属性操作的实现

属性包括：求树节点数目，高度，度数

count(node)，在node为根节点的树中统计节点数目

```c++
template <typename T>
int GTree<T>::count(GTreeNode<T>* node) const
{
    int ret = 0;
    if(node != nullptr)
    {
        ret = 1;
        for(node->child.move(0); !node->child.end(); node->child.next())
        {
            ret += count(node->child.current());
        }
    }
    return ret;
}

template <typename T>
int GTree<T>::count() const
{
    return count(root()) ;
}
```



---

高度，`height(node)` 获取 `node` 为根节点的树的高度

```c++
template <typename T>
int GTree<T>::height(GTreeNode<T>* node) const
{
    int ret = 0;
    if(node != nullptr)
    {
        for(node->child.move(0); !node->child.end(); node->child.next())
        {
            int h = height(node->child.current());
            if(ret < h)
            {
                ret = h;
            }
        }
        ret += 1;
    }
    return ret;
}

template <typename T>
int GTree<T>::height() const
{
    return height(root());
}
```



---

度数，`degree(node)` 获取 `node` 根节点的树的度数



```c++
template <typename T>
int GTree<T>::degree(GTreeNode<T>* node) const
{
    int ret = 0;
    if(node!= nullptr)
    {
        ret = node->child.length();
        for(node->child.move(0);!node->child.end(); node->child.next())
        {
            int d = degree(node->child.current());
            if(ret < d)
            {
                ret =d;
            }
        }
    }
    return ret;
}

template <typename T>
int GTree<T>::degree() const
{
    return degree(root());
}
```



### 树形结构的层次遍历

如何按层次遍历通用树结构中的每一个元素

树是非线性数据结构，树的节点没有固定的编号方式

---

需求：为树提供新方法

- 定义一个**游标** `GTreeNode<T>*`

- 遍历开始前将游标指向根节点

- 获取游标指向的数据元素

- 通过节点中的 `child` 成员移动游标

---

设计思路：提供一组遍历相关函数，按层次访问树中的数据元素

| 函数      | 描述                     |
| --------- | ------------------------ |
| begin()   | 初始化，准备进行遍历访问 |
| next()    | 移动游标，指向下一个节点 |
| current() | 获取游标所指向的数据元素 |
| end()     | 判断游标是否达到尾部     |









## 树到二叉树的转换

树的结构模型

第一种：==双亲孩子表示法==

- 每个节点都有一个指向其双亲的指针

- 每个节点都有若干个指向其孩子的指针



---

第二种：==孩子兄弟表示法==

- 能够表示任意的树形结构，每个节点包含一个数据成员和两个指针成员（孩子节点指针和右兄弟节点指针）

- 孩子节点指针和右兄弟节点指针构成了树杈



---

二叉树

由 `n(n>=0)` 个节点组成的有限集合（`n=0` 时为空树），由**一个根节点**加上两棵子树（**左子树**和**右子树**），互不相交的二叉树组成

**二叉树是最多只有两个孩子的树**

二叉树的5中形态

空  			只有一个节点   		只有左节点   		只有右节点		 具有左右节点

---

特殊的二叉树

满二叉树 Full Binary Tree

​		如果二叉树中所有分支节点的度都为2，且叶子节点都在一层上，则称为满二叉树

---

完全二叉树 Completed Binary Tree

​		如果一棵具有n个节点高度为k的二叉树，每个节点都与高度为k的满二叉树中编号为 1-n 的节点一一对应，这称为完全二叉树（从上到下从左到右编号）

完全二叉树的特性

- 同样节点数的二叉树，**完全二叉树的高度最小**

- **完全二叉树的叶节点仅出现在最下面两层**

  最底层的叶节点一定出现在左边

  倒数第二层的叶节点一定出现在右边

  完全二叉树中度为1的节点只有左孩子

> 关系：满二叉树是完全二叉树，而完全二叉树是正在形成的满二叉树



### 二叉树的深层特性



**性质一**：二叉树的第 `i` 层最多有 `2^(i-1)` 个节点，如第一次最多1个，第二层2个，第三次4个

**性质二**：高度为k的二叉树最多有 2^k - 1个节点

**性质三**：对任何一棵二叉树，如果叶节点有 n0 个，度为2的非叶节点有 n2 个，那么 n0=n2+1

**性质四**：具有n个节点的完全二叉树的高度为 || log2(n) || （不大于X的最大整数）+1 

**性质五**：一棵有n个节点的完全二叉树，按层次对节点进行编号（从上到下，左到右），对任意节点i，有

i=1：则节点i是二叉树的根

i>1 ： 其双亲节点为 







### 二叉树的存储结构设计



> 类设计：BTree



设计

- `BTree` 为二叉树结构，每个节点最多只有两个后继节点

- `BTreeNode` 只包含4个固定的公有成员

- 实现树结构的操作（增、删、查等）



```C++
template <typename T>
class BTreeNode : public TreeNode<T>
{
public:
	BTreeNode<T>* left;
	BTreeNode<T>* right;
	// 工厂模式
};
```



```C++
template <typename T>
class BTree: public Tree<T>
{
	// 实现
};
```





### 二叉树中的节点查找



——基于数据元素值的查找

```c++
virtual BTreeNode<T>* find(const T& value) const  ;
```

​    





——基于节点

```C++
virtual BTreeNode<T>* find(TreeNode<T>* node ) const ;
```









### 二叉树中的节点插入

不能在二叉树的任意节点插入子节点，只能插入到左节点和右节点

可以指定新数据元素（新节点）的插入位置

二叉树的位置枚举类型

```C++
enum BTNodePos
{
	ANY,LEFT,RIGHT
};
```



——插入数据元素

```c++
virtual bool insert(const T& value, TreeNode<T>* parent) ;  // 插入到任意位置（左或右），相当于 pos = ANY
bool insert(const T& value, TreeNode<T>* parent, BTNodePos pos) ;
```





——插入节点

```C++
virtual bool insert(TreeNode<T>* node ) ;  // 插入到任意位置（左或右），相当于 pos = ANY
bool insert(TreeNode<T>* node,BTNodePos pos ) ;
```



---

总结

- 二叉树插入时需要指明插入位置

- 插入数据元素时需要从堆空间中创建节点

- 当数据元素插入失败时需要释放节点空间

### 二叉树中的节点删除与清除



——**基于数据元素**删除

```C++
virtual SharedPointer<Tree<T> > remove(const T& value) ;
```





——**基于节点**删除

```C++
virtual SharedPointer<Tree<T> > remove(TreeNode<T >* node) ;
```






清除操作

```c++
template <typename T>
  void BTree<T>::free(BTreeNode<T>* node)
{
    if(node != nullptr)
    {
        free(node->left);
        free(node->right);
        if(node->flag())
        {
            delete node;
        }
    }
}

template <typename T>
 void BTree<T>::clear()
{
	free(root());
	this->m_root = nullptr;
}
```





### 二叉树中属性操作的实现





数量、高度、度









### 二叉树结构的层次遍历

层次遍历指从根节点出发，按照某种次序依次访问二叉树中的所有节点。

```C++
virtual bool begin()
    {
        bool ret = ( root() != nullptr);
        if(ret)
        {
            m_queue.clear();
            m_queue.add(root());
        }
        return ret;
    }
    virtual bool end()
    {
        return (m_queue.length() == 0);
    }
    virtual bool next()
    {
        bool ret = (m_queue.length() > 0);
        if(ret)
        {
            BTreeNode<T>* node = m_queue.front();
            m_queue.remove();
            if(node->left != nullptr)
            {
                m_queue.add(node->left);
            }
            if(node->right != nullptr)
            {
                m_queue.add(node->right);
            }
        }
        return ret;
    }
   virtual  T current()
    {
        if( ! end())
        {
            return m_queue.front()->value;
        }
        else
        {
            THROW_EXCEPTION(InvalidOperationException,"no value at current postion...");
        }
    }
```

---

层次遍历方式

---

==先序遍历== `Pre-Order Travesal`

——若二叉树为空，直接返回

——若二叉树不为空，（1）访问根节点中的数据元素；（2）先序遍历左子树；（3）先序遍历右子树









---

==中序遍历== `In-Order Travesal`

——若二叉树为空，直接返回

——若二叉树不为空，（1）中序遍历左子树；（2）访问根节点中的数据元素；（3）中序遍历右子树







---

==后续遍历== `Pre-Order Travesal`

——若二叉树为空，直接返回

——若二叉树不为空，（1）后序遍历左子树；（2）后序遍历右子树；（3）访问根节点中的数据元素



---

功能开发

```c++
SharedPointer<Array<T>> traveral(BTTraversal order)
```

- 根据 `oder` 选择遍历算法（先序、中续、后续）

- 返回值为堆中的数组对象

- 数组元素的次序反映遍历的先后次序







```c++
// 使用
SharedPointer<Array<int>> sp = nullptr;
sp = tree.traversal(PreOrder);
for(int i = 0 ; i<(*sp).length(); i++)
{
	cout<<(*sp)[i];
}
```



---

总结

二叉树的遍历方式都是采用**递归**，遍历结果能够反映树节点访问的先后次序



### 二叉树的比较和相加

==二叉树的克隆==：克隆当前树的一份拷贝，返回值是堆空间中的一棵新的二叉树（与当前树完全相同）

```c++
SharedPointer<BTree<T>> clone() const;
```

```C++
template <typename T>
BTreeNode<T>* BTree<T>::clone(BTreeNode<T>* node) const
{
    BTreeNode<T>* ret = nullptr;
    if(node != nullptr)
    {
        ret = BTreeNode<T>::NewNode();
        if(ret != nullptr)
        {
            ret->value = node->value;
            ret->left = clone(node->left);
            ret->right = clone(node->right);
            if(ret->left != nullptr)
            {
                ret->left->parent = ret;
            }
            if(ret->right != nullptr)
            {
                ret->right->parent = ret;
            }
        }
        else
        {
            THROW_EXCEPTION(NoEnoughMemoryException,"NO memory to clone...");
        }
    }
    return ret;
}


 template <typename T>
SharedPointer<BTree<T>> BTree<T>::clone() const
{
    BTree<T>* ret = new BTree<T>();
    if(ret != nullptr)
    {
        ret->m_root = clone(root());
    }
    else
    {
        THROW_EXCEPTION(NoEnoughMemoryException,"NO memory to clone...");
    }
    return ret;
}

```

==二叉树的比较==：判断两棵二叉树中的元素是否对应相等

```c++
bool operator ==(const BTree<T>& btree)
bool operator !=(const BTree<T>& btree)
```

```C++
template <typename T>
bool BTree<T>::equal(BTreeNode<T>* lh,BTreeNode<T>* rh)
{
    bool ret = false;
    if(lh == rh)
    {
        ret = true;
    }
    else if( (lh!= nullptr)&& (rh != nullptr) )
    {
        ret =  ( (lh->value == rh->value) && (equal(lh->left,rh->left)) && (equal(lh->right, rh->right)) );
    }
    else
    {
        ret = false;
    }
    return ret;
}

template <typename T>
bool BTree<T>::operator ==(const BTree<T>& btree)
{
    return equal(this->root(),btree.root());
}
template <typename T>
bool BTree<T>::operator !=(const BTree<T>& btree)
{
    return !( (*this) == btree );
}
```



---

==二叉树的相加==：将当前二叉树与参数二叉树中的数据元素在**对应位置处**相加，并返回相加后得到的二叉树（一棵新的二叉树）

```C++
SharedPointer<BTree<T>> add(const BTree<T>& btree) const;
```

```c++
template <typename T>
BTreeNode<T>* BTree<T>::add(BTreeNode<T>* lh, BTreeNode<T>* rh) const
{
    BTreeNode<T>* ret = nullptr;
    if( lh == nullptr && rh != nullptr)
    {
        ret = clone(rh);
    }
    else if( lh != nullptr && rh == nullptr)
    {
        ret = clone(lh);;
    }
    else if( lh != nullptr && rh != nullptr)
    {
        ret = BTreeNode<T>::NewNode();
        if(ret != nullptr)
        {
            ret->value = lh->value + rh->value;
            ret->left = add(lh->left,rh->left);
            ret->right = add(lh->right,rh->right);
            if(ret->left != nullptr)
            {
                ret->left->parent = ret;
            }
            if(ret->right != nullptr)
            {
                ret->right->parent = ret;
            }
        }
        else
        {
            THROW_EXCEPTION(NoEnoughMemoryException,"no memory to create new tree");
        }
    }

    return ret;
}

template <typename T>
SharedPointer<BTree<T>> BTree<T>::add(const BTree<T>& btree) const
{
    BTree<T>* ret = new BTree<T>();
    if(ret != nullptr)
    {
        ret->m_root = add(root(),btree.root());
    }
    else
    {
        THROW_EXCEPTION(NoEnoughMemoryException,"no memory to create new tree");
    }
    return ret;
}
```



### 二叉树的线索化实现

线索化：二叉树建立起来后应用中不修改，但是需要经常访问（之前的遍历用的递归太慢了）

- 将二叉树转换为双向链表的过程（非线性→线性）

- 能够反映某种二叉树的遍历次序（节点的先后访问次序）

  利用节点的 `right` 指向遍历中的后继节点

  利用节点的 `left` 指向遍历中的前驱节点



```c++
traversal(BTTraversal order,queue)  // 新增功能函数
BTTraversal::LevelOrder;
BTreeNode<T>* thread(BTTraversal order);  // 新增公有函数
/*
根据 order 选择线索化的次序（先序、中续、后续、层次）
返回值是线索化之后指向链表首节点的指针，执行结束后二叉树变成空
*/
```



---

总结

- 线索化是将二叉树转换为双向链表的过程

- 线索化之后节点间的先后次序符合某种遍历次序

- 线索化将破坏原有二叉树节点间的父子关系，线索化之后二叉树被清空

### 二叉树经典面试题

Q1：单度节点删除，用于删除二叉树中的所有单度节点，删除后，其唯一的子节点代替原位置

| 0       |         |         |
| ------- | ------- | ------- |
| 1       | 2       |         |
| 左3     | 左4     | 右5     |
| （右6） | （左7） | （左8） |

删除后

| 0    |          |
| ---- | -------- |
| 6    | 2        |
|      | （7，8） |



---

情况一：节点中包含父节点指针

```C++
template <typename T>
BTreeNode<T>* delOdd1(BTreeNode<T>* node)
{
    BTreeNode<T>* ret = nullptr;
    if(node != nullptr)
    {
        if( ((node->left != nullptr) && (node->right == nullptr))  ||\
                ((node->left == nullptr) && (node->right != nullptr)) )
        {
            BTreeNode<T>* parent = dynamic_cast<BTreeNode<T>*>(node->parent);
            BTreeNode<T>* node_child = ( node->left != nullptr)?node->left:node->right;
            if(parent != nullptr)
            {
                BTreeNode<T>*& parent_child = (parent->left == node)?parent->left:parent->right;

                parent_child = node_child;

                node_child->parent = parent;
            }
            else
            {
                node_child->parent = nullptr;
            }
            if(node->flag())
            {
                delete node;
            }
             ret = delOdd1(node_child);
        }
        else
        {
            delOdd1(node->left);
            delOdd1(node->right);
            ret =  node;
        }
    }
    return ret;
}
```



情况二：节点中不包含父节点指针

```C++
template <typename T>
BTreeNode<T>* delOdd2(BTreeNode<T>*& node)
{
    BTreeNode<T>* ret = nullptr;
    if(node != nullptr)
    {
        if( ((node->left != nullptr) && (node->right == nullptr))  ||\
                ((node->left == nullptr) && (node->right != nullptr)) )
        {
            BTreeNode<T>* node_child = (node->left != nullptr)?node->left:node->right;

            if(node->flag())
            {
                delete node;
            }
            node = node_child;
            ret = delOdd2(node);
        }
        else
        {
            delOdd2(node->left);
            delOdd2(node->right);
            ret =  node;
        }
    }
    return ret;
}
```





---

Q2：中续线索化二叉树，不使用其它数据结构

解法一：在中续遍历的同时进行线索化

​	使用辅助指针，在中序遍历时指向当前节点的前驱节点

​	访问当前节点时，连接与前驱节点的先后次序

```c++
inOrderThread(BTreeNode<T>* node,pre)
```



---

解法二：中序遍历的节点次序正好是节点的水平次序

思路：使用辅助指针，指向转换后双向链表的头节点和尾节点

​			根节点与左右子树转换的双向链表连接，称为完整双向链表



```C++
template <typename T>
void inOrderThread(BTreeNode<T>* node , BTreeNode<T>* & head, BTreeNode<T>* & tail)
{
   if(node != nullptr)
   {
       BTreeNode<T>* h = nullptr;
       BTreeNode<T>* t = nullptr;

       inOrderThread(node->left, h, t);
       node->left = t;
       if(t != nullptr)
       {
           t->right = node;
       }

       head = (h!= nullptr)?h:node;

       h = nullptr;
       t = nullptr;

       inOrderThread(node->right,h, t);
       node->right = h;
       if(h != nullptr)
       {
           h->left = node;
       }
       tail = (t!= nullptr)? t : node;
   }
}

template <typename T>
BTreeNode<T>* inOrderThread4(BTreeNode<T>* node )
{
    BTreeNode<T>* head = nullptr;
    BTreeNode<T>* tail = nullptr;
    inOrderThread(node, head, tail);
    return head;

}
```







## 图

图是由顶点集合 `Vertex` 及顶点间的关系集合 `Edge` 组成的一种数据结构

> Graph = (V, E)

二叉树是特殊的图

链表是特殊的二叉树（每个节点有且只有一个直接后续）

---

无向边：顶点x和y之间的边没有方向，则称该边为无向边。（x,y）与 （y,x）意义相同，表示 x 和 y 之间有连接

**无向图**：图中任意两个顶点之间的边都是无向边

---

有向边：顶点x和y的边有方向，则称该边为有向边。

- <x,y>：从 x 连接到 y，x 是尾，y 是头（出发的点叫尾）

- <y,x>：从 y 连接到 x

**有向图**：图中任意两个顶点之间的边均是有向边

无向图是特殊的有向图

---

**顶点邻接 ** Adjacent

无向图：x 与 y 连接

有向图：<x,y> 表示点 x 邻接到 y

---

**度**：顶点v的度是和v相关联的边的数目，记作 `TD(v)`

入度：以 v 为头的边的数目，记为 `ID(v)`

出度：以 v 为尾的边的数目，记为 `OD(v)`

入度和出度是有向图才有的

```c++
TD(v) = ID(v) + OD(v) 
Count(E) = 所有出度的数量 = 所有入度的数量 = （所有节点的度的数量）/ 2
```

---

**权** weight：与图的边相关的数据元素

权常用来表示图中顶点间的距离或耗费

---

常用操作：设置顶点的值、获取顶点的值、获取邻接顶点、设置边的值、删除边、获取顶点数、获取边数





```c++
template <typename V,typename E>  // V 是顶点数据，E 是权值
class Graph: public Object
{
public:
	virtual V getVertex(int i) = 0;
	virtual bool getVertex(int i, V& value) = 0;
	virtual bool setVertex(int i, const V& value) = 0;
	virtual SharedPointer<Array<int>> getAdjacent(int i) = 0;
	virtual E getEdge(int i , int j) = 0;
	virtual bool getEdge(int i, int j, E& value) = 0;
	virtual bool setEdge(int i, int j, const E& value) = 0;
	virtual bool removeEdge(int i, int j) = 0;
	virtual int vCount() = 0;
	virtual int eCount() = 0;
	virtual int OD(int i) = 0;
	virtual int ID(int i) = 0;
	virtual int TD(int i) = 0;

};
```

---

==小结==

- 图是顶点与边的集合，一种非线性数据结构

- 图中顶点可以与多个其他顶点产生邻接关系


- 图中的边有与之对应的权值，表示顶点间的距离




### 图的存储结构

基本思路

1. 用一维数组存储顶点：描述顶点相关的数据
2. 用二维数组存储边：描述顶点间的关系和权

邻接矩阵法： `Edge[i][j]` ，

- 若 i 与 j 相连，其值为权；

- 若 i 与 j 不连接，其值为空

 `Edge[i][j]` 

无向图的为对称矩阵，对角线元素全为 0

有向图的为对称/非对称矩阵，对角线元素全为 0

---

> 类设计：Object 顶层父类 ，  Graph 抽象父类， MatrixGraph 之类



```C++
template <int N, typename V, typename E>
class MatrixGraph : public Grap<V,E>
{
	protected:
	V m_vertexes[N];
	E m_edges[N][N];
	int m_eCount();
	public:  // 实现父类中的函数
};
```



---

==缺陷==

```C++
struct TE
{
	int a[100];
	TE(){}
}
MatrixGraph<100,TE,TE> test;  // 调用 TE 的构造函数 100+100*100次
```

构造效率低：图对象初始化时，频繁调用顶点类型和边类型的构造函数

空间使用率低：图对象占用大量空间，而大多数空间处于闲置状态

无法表示空值：无法用统一的方式表示边为空的情形

---

==方案：使用指针数组表示顶点集和边集==

```c++
template <int N, typename V, typename E>
class MatrixGraph : public Grap<V,E>
{
	protected:
	V* m_vertexes[N];
	E* m_edges[N][N];
	int m_eCount();
	public:  // 实现父类中的函数
};
```

 构造时：初始化图对象时，只需要将数组元素赋值为空

空间使用：顶点数据元素和边数据元素在需要时动态创建

空值的表示：任意顶点类型和边类型都用 `nullptr` 来表示空值



---

==缺陷==

MatrixGraph  无法动态增加/删除 顶点

```C++
V* m_vertexes[N];
E* m_edges[N][N];
当创建对象时 N = 10000；
邻接矩阵的体积是4*1000*1000，体积约为4MB
```

为进一步提高空间使用率，使用**链表代替数组**，将邻接矩阵变换为邻接链表

---

==邻接链表法==  ListGraph

- 图中所有的顶点按编号存储于同一个链表中

- 每一个顶点对应一个链表，用于存储始发于该顶点的边

- 每一条边的信息包含：起点、终点、权值

> 类设计：与 MatrixGraph 一样，继承自 Graph

==第一步==：定义数据类型

```c++
struct Vertex : public Object  // 顶点数据类型
{
   V* data;   // 顶点数据元素
	LinkList<Edge> edge;   // 邻接与该顶点的边
};
struct Edge : public Object  // 边数据类型
{
	int b;   // 起始顶点
	int a;   // 邻接顶点
	E data;   // 权值
};
```

==第二步==：动态增加/删除 顶点

```C++
int addVertex();  // 增加新的顶点，返回顶点编号，只能在原图的末尾增加
int addVertex(const V& value);  // 增加新顶点（其值为value）
void removeVertex();  // 删除最近增加的顶点
```



---

小结

- 邻接链表法使用链表对图相关的数据进行存储

- 每一个顶点关联一个链表，用于存储边相关的数据

- 领接链表实现的图能够动态添加/删除顶点

| 函数         | MatrixGraph | ListGraph |
| ------------ | ----------- | --------- |
| addVertex    |             | O(n)      |
| removeVertex |             | O(n^2)    |
| getVertex    | O(1)        | O(n)      |
| setVertex    | O(1)        | O(n)      |
| getAdjacent  | O(n)        | O(n)      |
| getEdget     | O(1)        | O(n)      |
| setEdget     | O(1)        | O(n)      |
| removeEdge   | O(1)        | O(n)      |
| vCount       | O(1)        | O(1)      |
| eCount       | O(1)        | O(n)      |
| OD           | O(n)        | O(n)      |
| ID           | O(n)        | O(n^2)    |

`MatrixGraph` 适用与内存资源丰富的场合（性能较好）

`ListGraph` 的空间使用率高，适用于内存资源受限的场合（节省空间）

---

Bug ListGraph存在问题

```
getEdge(j,i);会抛出异常 j=-1
```

```C++
template <typename V, typename E>
bool LinkGraph<V,E>::setEdge(int i, int j, const E& value)
{
    bool ret = ( (0<= i) && (i<vCount()) &&  \
                 (0<= j) && (j<vCount()));
    if(ret)
    {
        Vertex* vertex = m_list.get(i);
        int pos = vertex->edge.find(Edge<E>(i,j));
        if(pos >= 0)   // 此处是大问题
        {
            ret = vertex->edge.set(pos,Edge<E>(i,j,value));
        }
        else
        {
            ret = vertex->edge.insert(0,Edge<E>(i,j,value));
        }
    }
    return ret;
}
```





是偶发性bug

### 图的遍历

指从图中某一顶点出发，沿着一些边访问图中所有其他顶点，使得每个顶点**最多被访问一次**（有的顶点可能遍历不到）

- **广度优先**（Breadth First Search, BFS）

  以二叉树层次遍历的思想对图进行遍历

- **深度优先**（Depth First Search, DFS）

  以二叉树先序遍历思想对图遍历

#### BFS

需要 `LinkQueue<T>`

1. 将起始顶点压入队列
2. 队头顶点v弹出，判断是否已经标记（标记：转2；未标记：转3）
3. 标记顶点v，并将顶点v的邻接顶点压入队列中
4. 判断队列是否为空（非空：转2；空：结束）



```c++
template <typename T>
    DynamicArray<T>* toArray(LinkQueue<T>& queue)  // 将 队列 转换成 array
    {
        DynamicArray<T>* ret = new DynamicArray<T>(queue.length());
        if(ret != nullptr)
        {
            for(int i = 0; i<ret->length(); ++i)
            {
                ret->set(i,queue.front());
                queue.remove();
            }
        }
        else
        {
            THROW_EXCEPTION(NoEnoughMemoryException,"no memory to create ret object...");
        }
        return ret;
    }

    SharedPointer<ArrayM<int>> BFS(int i)
    {
        DynamicArray<int>* ret = nullptr;
        if( (i>=0) && (i<vCount()) )

        {
            LinkQueue<int > q;
            LinkQueue<int> r;
            DynamicArray<bool > visited(vCount());
            for(int i =0; i< vCount(); ++i)
            {
                visited[i] = false;
            }
            q.add(i);
            while(q.length() >0)
            {
                int v = q.front();
                q.remove();
                if(!visited[v])
                {
                    SharedPointer<ArrayM<int>> aj = getAdjacent(v);
                    for(int j = 0; j<aj->length(); ++j)
                    {
                        q.add((*aj)[j]);
                    }
                    r.add(v);
                    visited[v] = true;
                }
            }
            ret = toArray(r);
        }
        else
        {
            THROW_EXCEPTION(InvalidOperationException,"");
        }
        return ret;
    }
```

#### DFS

深度优先

原料 `LinkStack<T>`

1. 将起始顶点压入栈中
2. 弹出栈顶顶点v，判断是否已经被标记（标记，转2；未标记，转3）
3. 标记顶点v，并将顶点v的邻接顶点压入栈中
4. 判断栈是否为空（非空，转2；为空，结束）



```c++
SharedPointer<ArrayM<int>> DFS(int i)
    {
        DynamicArray<int>* ret = nullptr;
        if( (i>=0) && (i<vCount()) )
        {
            LinkStack<int> s;
            LinkQueue<int> r;
            DynamicArray<bool> visited(vCount());
            for(int j =0; j< vCount(); ++j)
            {
                visited[j] = false;
            }
            s.push(i);
            while(s.size()>0)
            {
                int v = s.top();
                s.pop();
                if(!visited[v])
                {
                    SharedPointer<ArrayM<int>> aj = getAdjacent(v);
                    for(int j = aj->length() - 1; j>=0; j--)
                    {
                        s.push((*aj)[j]);
                    }
                    r.add(v);
                    visited[v] = true;
                }
            }
            ret = toArray(r);
        }
        else
        {
            THROW_EXCEPTION(InvalidParameterException,"index i is invalid...");
        }
        return ret;
    }
```



---

如何使用二叉树先序遍历的思想：使用**递归版深度优先**

定义功能 `DFS(graph, vex)`，以顶点vex为起始点深度优先遍历 graph

```C++
template <typename V, typename E>
void DFS(Graph<V,E>& g, int v, ArrayM<bool>& visited)
{
    if( (0<=v) && (v<g.vCount()) )
    {
        cout<<"void DFS "<<v<<endl;
        visited[v] = true;
        SharedPointer<ArrayM<int>> aj = g.getAdjacent(v);
        for(int i = 0; i<aj->length(); ++i)
        {
            if(!visited[(*aj)[i]])
            {
                DFS(g,(*aj)[i],visited);
            }
        }
    }
    else
    {
        THROW_EXCEPTION(InvalidParameterException,"index v is invalid in void DFS(Graph<V,E>& g, int v, ArrayM<bool>& visited)...");
    }
}

template <typename V, typename E>
void DFS(Graph<V,E>& g, int v)
{
    DynamicArray<bool> visited(g.vCount());
    for( int i =0; i< visited.length(); ++i)
    {
        visited[i] = false;
    }
    DFS(g,v,visited);
}
```



---

小结

深度优先按照“先序遍历的方式”对顶点进行访问

深度优先算法的核心是栈的使用，而广度优先核心在于队列的使用

深度优先可以使用递归实现

### 最小生成树Prim

最小生成树需满足

1. 仅使用图中的 `n-1` 条边连接图中的 `n` 个顶点
2. 不能使用产生回路的边
3. 各边上的权值的总和达到最小

最小生成树仅针对无向图有意义，必须判断图对象是否能够看做无向图

---

原材料如下

| 类型        | 变量名 | 用途                                     |
| ----------- | ------ | ---------------------------------------- |
| Array<bool> | mark   | 用于标记顶点所属的集合（T or E）         |
| Array<E>    | cost   | 记录 T 集合到 F 集合中各个顶点的最小权值 |
| Array<int>  | adjVex | 记录 cost 中权值的对应顶点               |
| Queue<Edge> | ret    | 记录最小生成树中的边                     |

备注：如果 T 集合到 F 集合中同一个顶点的连接有多条，那么取权值最小的连接



---

`Prim` 算法步骤

1. 选择某一顶点 v0 作为起始顶点，使得 T = { v0 }, F = { v1, v2, ... , vn}, E = { }

2. 每次选择一条边，这条边是所有 (u,v) 中权值最小的边，且 u属于T，v 属于 E

3. 修改 T, F, E

   T= T+ {v};  F = F - {v}; E = E+ {(u,v)}

4. 当 F != NULL 时，且 (u,v) 存在，转步骤2；否则，结束



---



```c++
virtual bool isAdjacent(int i, int j) = 0;  // 判断在当前图中顶点i到顶点j是否邻接
bool asUndirected();  // 判断当前的有向图是否能够看作无向图
```







最大生成树也是同理

### 最小生成树Kruskal

特征

- 所选的边是图中权值最小的边

- 所有边连接后不构成回路

既然最小生成树关心的是如何选择n-1条边，那么可以直接以边为核心来设计

技巧：前驱标记数组 `Array<int> p(vCount())`

意义：`p[n]` 表示顶点n在边的连接通路上的另一端顶点









### 最短路径Dijkstral

有向图中，从起始顶点→终止顶点，找到一条路径，使得路径各边上的权值总和达到最小

Dijkstra 提出按路径长度的递增次序（**递归**实现），逐步产生最短路径

1. 首先，求出长度最小的一条路径，再参照它求出长度次短的一条最短路径
2. 依次类推，直到从起始顶点v到其他各顶点的最短路径全部求出为止



原理：通过已知的最短路径值，来推未知的最短路径

算法步骤





代码实现



---

小结

Dijkstra最短路径是基于递推的思想

未标记顶点的最短路径只能由已知标记顶点计算得出

算法的最终结果是起始顶点到其他各个顶点的最短路径

### 最短路径Floyd



需要求任意两个顶点的最短路径：将图中的顶点依次作为起始顶点，执行n次 Dijkstra 算法即可

```c++
int path[N][N];
E dist[N][N];
for(int i = 0; i<N; ++i)  dijkstra(i,dist[i],path[i]);
```

执行完之后，i 到 j 的最短路径存储在 dist[i][j]

---

更好的方案：Floyd

问题：已知一个各边权值均大于0的带权有向图，对每一对顶点 vi 和 vj（vi≠vj），求出vi与vj 之间的最短路径以及最短路径上的顶点







原理：递推

算法精髓：

- A（-1）定义为领接矩阵，则，A（0）...A(n-1)通过中转顶点逐一递推得到

- A（k）矩阵中元素的更新

  `A（k）[i][j]`  =  min (  `A(k-1)[i][j]` , `A(k-1)[i][k]` + `A(k-1)[k][j]`  )

- A 矩阵的推导就是最短路径的推导：`A[i][j]` 为 i 到 j 的路径值， 在推导过程中逐步减小

  推导到 A(n-1) 时，任意两个顶点之间的最短路径就得出

---

步骤一：初始化

```c++
for(int i = 0; i<vCount(); ++i)
{
	for(int j =0; j<vCount(); ++j)
	{
		dist[i][j] = getEdge(i,j);
	}
}
```

步骤二：推导 A(0)、  A(1) ... A(n-1)，  本质：使用中转顶点逐步推导最短路径

```c++
for(int k = 0; k<vCount(); ++k)
{
	for(int i =0; i<vCount(); ++i)
	{
		for(int j =0; j<vCount(); ++j)
		{
			if( dist[i][k] + dist[k][j] < dist[i][j])
			{
			dist[i][j] =  dist[i][k] + dist[k][j];
			}
		}
	}
}
```



---

具体实现

```C++
int Floyd(int x, int y, const E& LIMIT)
    {
        int ret = -1;
        if( (x >=0) && (y>=0) && (x<vCount())  && (y<vCount())  )
        {
            int dist[vCount()][vCount()];

            for(int i =0; i<vCount(); ++i)
            {
                for(int j =0; j<vCount(); ++j)
                {
                    dist[i][j] = isAdjacent(i,j)? getEdge(i,j) : LIMIT;
                }
            }
            for(int k = 0; k<vCount(); ++k)
            {
                for(int i =0; i<vCount(); ++i)
                {
                    for(int j =0; j<vCount(); ++j)
                    {
                        if( (dist[i][k]+dist[k][j]) < dist[i][j] )
                        {
                            dist[i][j] = dist[i][k]+dist[k][j];
                        }
                    }
                }
            }
            ret = dist[x][y];
        }
        else
        {
            THROW_EXCEPTION(InvalidParameterException,"index <x,y> is invalid");
        }
        return ret;
    }
```

只实现了求最短路径值，而没有记录最短路径

方案：定义辅助矩阵 `int path[N][N]` 路径矩阵

`path[i][j]`表示i到j的路径上所经过的第1个顶点

初始化  ` path[i][j]=-1 或 = j` (有边连接的就是 j )

修改

```c++
if( (dist[i][k]+dist[k][j]) < dist[i][j] )
 {
	dist[i][j] = dist[i][k]+dist[k][j];
	path[i][j] = path[i][k];
}
```









### 最长不下降序列



不下降序列问题

由 n 个数组组成的数列，记为` a[1]、...a[n]` ，若存在 `i1<i2<...<im`，满足 `a[i1] <= a[i2] <= ... <= a[im]`，则称长度为 m 的不下降序列

如何求最长不下降序列，以及所有不下降序列

---

问题建模

使用数列中的元素和元素间的关系建立**有向图**模型

- 图中顶点的附加数据值为对应的数列元素值

- 图中的边按照如下方式建立

  ​	当数列中的某个元素与后续元素存在不下降关系时

  ​			（1）从该元素对应的顶点到后续元素对应的顶点存在一条有向边

  ​			（2）边的权值固定为1





---

解决思路

以每一个顶点作为起始顶点寻找局部最多顶点路径

再寻找全局最多顶点的路径



原材料

Array<int> count;  count[i]  表示以i起始的最多顶点路径上的顶点数

Array<int> path;  path[i] 表示以i起始的最多顶点路径上经过的第一个顶点

Array<bool> mark;  如果i起始的最多顶点路径已找到，则 mark[i] 为true











---

Bug

```C++
int a[] = {  1,3,5,4  };
solution(a,sizeof(a)/sizeof(*a));   // 结果只能找到 124
```

原因

同理：int a[] = {  1,3,9,8,7,6,5  };  只能得到 12 5

Array<int> path;  以3为顶点查找最大不下降序列时，找到了 {9} {8} {7} ... {5} 因为他们都长度相等，所以只保留了 {5}

解决方案

Array<LinkList<int>*> path; 







2025年4月11日完结













